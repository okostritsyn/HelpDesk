////////////////////////////////////////////////////////////////////////////////
// Подсистема "Базовая функциональность".
// Клиентские и серверные процедуры и функции общего назначения:
// - для поддержки формирования печатных форм;
// - для работы с файлами;
// - для работы с управляемыми формами; 
// - для работы с почтовыми адресами;
// - для работы с отборами динамических списков;
// - прочее.
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// ПРОГРАММНЫЙ ИНТЕРФЕЙС

// Формирует и выводит сообщение, которое может быть связано с элементом 
// управления формы.
//
//  Параметры
//  ТекстСообщенияПользователю - Строка - текст сообщения.
//  КлючДанных                - Любая ссылка на объект информационной базы.
//                               Ссылка на объект информационной базы, к которому это сообщение относится,
//                               или ключ записи.
//  Поле                       - Строка - наименование реквизита формы
//  ПутьКДанным                - Строка - путь к данным (путь к реквизиту формы)
//  Отказ                      - Булево - Выходной параметр
//                               Всегда устанавливается в значение Истина
//
//	Примеры использования:
//
//	1. Для вывода сообщения у поля управляемой формы, связанного с реквизитом объекта:
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ,
//		"ПолеВРеквизитеФормыОбъект",
//		"Объект");
//
//	Альтернативный вариант использования в форме объекта:
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ,
//		"Объект.ПолеВРеквизитеФормыОбъект");
//
//	2. Для вывода сообщения рядом с полем управляемой формы, связанным с реквизитом формы:
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ,
//		"ИмяРеквизитаФормы");
//
//	3. Для вывода сообщения связанного с объектом информационной базы
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ОбъектИнформационнойБазы, "Ответственный",,Отказ);
//
// 4. Для вывода сообщения по ссылке на объект информационной базы
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), Ссылка, , , Отказ);
//
// Случаи некорректного использования:
//  1. Передача одновременно параметров КлючДанных и ПутьКДанным
//  2. Передача в параметре КлючДанных значения типа отличного от допустимых
//  3. Установка ссылки без установки поля (и/или пути к данным)
//
Процедура СообщитьПользователю(
		Знач ТекстСообщенияПользователю,
		Знач КлючДанных = Неопределено,
		Знач Поле = "",
		Знач ПутьКДанным = "",
		Отказ = Ложь) Экспорт
	
	Сообщение = Новый СообщениеПользователю;
	Сообщение.Текст = ТекстСообщенияПользователю;
	Сообщение.Поле = Поле;
	
	ЭтоОбъект = Ложь;
	
#Если НЕ (ТонкийКлиент ИЛИ ВебКлиент) Тогда
	Если КлючДанных <> Неопределено
	   И XMLТипЗнч(КлючДанных) <> Неопределено Тогда
		ТипЗначенияСтрокой = XMLТипЗнч(КлючДанных).ИмяТипа;
		ЭтоОбъект = СтрНайти(ТипЗначенияСтрокой, "Object.") > 0;
	КонецЕсли;
#КонецЕсли
	
	Если ЭтоОбъект Тогда
		Сообщение.УстановитьДанные(КлючДанных);
	Иначе
		Сообщение.КлючДанных = КлючДанных;
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ПутьКДанным) Тогда
		Сообщение.ПутьКДанным = ПутьКДанным;
	КонецЕсли;
		
	Сообщение.Сообщить();
	
	Отказ = Истина;
	
КонецПроцедуры

// Добавляет в список ошибок новую ошибку пользователя для дальнейшей отправки
// с помощью процедуры СообщитьОшибкиПользователю().
//  Используется в процедурах ОбработкаПроверкиЗаполнения.
//
// Параметры:
//  Ошибки          - Неопределено - будет создан новый список,
//                  - значение, установленное при первом вызове этой процедуры со значением Неопределено.
//
//  ПолеОшибки      - Строка - значение, которое задается в свойстве Поле объекта СообщениеПользователю.
//                    Для автоподстаноски номера строки должна содержать "%1".
//                    Например, "Объект.ИНН" или "Объект.Пользователи[%1].Пользователь".
//
//  ТекстДляОднойОшибки - Строка - текст ошибки для случая, когда ГруппаОшибок в коллекции только одна,
//                    например, НСтр("ru = 'Пользователь не выбран.'").
//
//  ГруппаОшибок    - Произвольный - используется для выбора либо текста для одной ошибки,
//                    либо текста для нескольких ошибок, например, имя "Объект.Пользователи".
//                    Если значение не заполнено, тогда используется текст для одной ошибки.
//
//  НомерСтроки     - Число - значение от 0 ... , определяющее номер строки, который нужно подставить
//                    в строку ПолеОшибки и в ТекстДляНесколькихОшибок (подставляется НомерСтроки + 1).
//
//  ТекстДляНесколькихОшибок - Строка - текст ошибки для случая, когда добавлено несколько ошибок с одинаковым
//                    свойством ГруппаОшибок, например, НСтр("ru = 'Пользователь в строке %1 не выбран.'").
//
Процедура ДобавитьОшибкуПользователю(Ошибки, Знач ПолеОшибки, Знач ТекстДляОднойОшибки, Знач ГруппаОшибок = "", Знач НомерСтроки = 0, Знач ТекстДляНесколькихОшибок = "") Экспорт
	
	Если Ошибки = Неопределено Тогда
		Ошибки = Новый Структура;
		Ошибки.Вставить("СписокОшибок", Новый Массив);
		Ошибки.Вставить("ГруппыОшибок", Новый Соответствие);
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ГруппаОшибок) Тогда
		// При незаполненной группе ошибок используется текст для одной ошибки.
	Иначе
		Если Ошибки.ГруппыОшибок[ГруппаОшибок] = Неопределено Тогда
			// Группа ошибок использовалась один раз, используется текст для одной ошибки.
			Ошибки.ГруппыОшибок.Вставить(ГруппаОшибок, Ложь);
		Иначе
			// Группа ошибок использовалась несколько раз, используется текст для нескольких ошибок.
			Ошибки.ГруппыОшибок.Вставить(ГруппаОшибок, Истина);
		КонецЕсли;
	КонецЕсли;
	
	Ошибка = Новый Структура;
	Ошибка.Вставить("ПолеОшибки",               ПолеОшибки);
	Ошибка.Вставить("ТекстДляОднойОшибки",      ТекстДляОднойОшибки);
	Ошибка.Вставить("ГруппаОшибок",             ГруппаОшибок);
	Ошибка.Вставить("НомерСтроки",              НомерСтроки);
	Ошибка.Вставить("ТекстДляНесколькихОшибок", ТекстДляНесколькихОшибок);
	
	Ошибки.СписокОшибок.Добавить(Ошибка);
	
КонецПроцедуры

// Сообщает ошибки добавленные с помощью процедуры ДобавитьОшибкуПользователю().
//
// Параметры:
//  Ошибки  - Неопределено - возврат,
//            значение, установленное при использовании процедуры ДобавитьОшибкуПользователю().
//  Отказ   - Булево, устанавливается Истина, если ошибки сообщались.
//
Процедура СообщитьОшибкиПользователю(Знач Ошибки, Отказ = Ложь) Экспорт
	
	Если Ошибки = Неопределено Тогда
		Возврат;
	Иначе
		Отказ = Истина;
	КонецЕсли;
	
	Для каждого Ошибка Из Ошибки.СписокОшибок Цикл
		
		Если Ошибки.ГруппыОшибок[Ошибка.ГруппаОшибок] <> Истина Тогда
			
			СообщитьПользователю(
				Ошибка.ТекстДляОднойОшибки,
				,
				СтрЗаменить(Ошибка.ПолеОшибки, "%1", Формат(Ошибка.НомерСтроки, "ЧН=0; ЧГ=")));
		Иначе
			СообщитьПользователю(
				СтрЗаменить(Ошибка.ТекстДляНесколькихОшибок, "%1", Формат(Ошибка.НомерСтроки + 1, "ЧН=0; ЧГ=")),
				,
				СтрЗаменить(Ошибка.ПолеОшибки, "%1", Формат(Ошибка.НомерСтроки, "ЧН=0; ЧГ=")));
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Формирует путь к заданной строке НомерСтроки и колонке ИмяРеквизита 
// табличной части ИмяТабличнойЧасти для выдачи сообщений в форме.
// Для совместного использования с процедурой СообщитьПользователю
// (для передачи в параметры Поле или ПутьКДанным). 
//
// Параметры:
//  ИмяТабличнойЧасти - Строка - имя табличной части.
//  НомерСтроки       - Число - номер строки табличной части.
//  ИмяРеквизита      - Строка - имя реквизита.
//
// Возвращаемое значение:
//  Строка - путь к ячейке таблицы.
//
Функция ПутьКТабличнойЧасти(Знач ИмяТабличнойЧасти, Знач НомерСтроки, 
	Знач ИмяРеквизита) Экспорт

	Возврат ИмяТабличнойЧасти + "[" + Формат(НомерСтроки - 1, "ЧН=0; ЧГ=0") + "]." + ИмяРеквизита;

КонецФункции

// Дополняет таблицу значений-приемник данными из таблицы значений-источник.
//
// Параметры:
//  ТаблицаИсточник - ТаблицаЗначений - таблица, из которой будут браться строки для заполнения;
//  ТаблицаПриемник - ТаблицаЗначений - таблица, в которую будут добавлены строки из таблицы-источника.
//  
Процедура ДополнитьТаблицу(ТаблицаИсточник, ТаблицаПриемник) Экспорт
	
	Для Каждого СтрокаТаблицыИсточник Из ТаблицаИсточник Цикл
		
		ЗаполнитьЗначенияСвойств(ТаблицаПриемник.Добавить(), СтрокаТаблицыИсточник);
		
	КонецЦикла;
	
КонецПроцедуры

// Дополняет таблицу значений Таблица значениями из массива Массив.
//
// Параметры:
//  Таблица - ТаблицаЗначений - таблица, которую необходимо заполнить значениями из массива;
//  Массив  - Массив - массив значений для заполнения таблицы;
//  ИмяПоля - Строка - имя поля таблицы значений, в которое необходимо загрузить значения из массива.
// 
Процедура ДополнитьТаблицуИзМассива(Таблица, Массив, ИмяПоля) Экспорт

	Для каждого Значение Из Массив Цикл
		
		Таблица.Добавить()[ИмяПоля] = Значение;
		
	КонецЦикла;
	
КонецПроцедуры

// Дополняет массив МассивПриемник значениями из массива МассивИсточник.
//
// Параметры:
//  МассивПриемник - Массив - массив, в который необходимо добавить значения.
//  МассивИсточник - Массив - массив значений для заполнения,
//	ТолькоУникальныеЗначения - булево, необязательный, если истина, 
//		то в массив будут включены только те значения, которых в нем еще нет, причем единожды
// 
Процедура ДополнитьМассив(МассивПриемник, МассивИсточник, ТолькоУникальныеЗначения = Ложь) Экспорт

	УникальныеЗначения = Новый Соответствие;
	
	Если ТолькоУникальныеЗначения Тогда
		Для каждого Значение Из МассивПриемник Цикл
			УникальныеЗначения.Вставить(Значение, Истина);
		КонецЦикла;
	КонецЕсли;
	
	Для каждого Значение Из МассивИсточник Цикл
		Если ТолькоУникальныеЗначения И УникальныеЗначения[Значение] <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		МассивПриемник.Добавить(Значение);
		УникальныеЗначения.Вставить(Значение, Истина);
	КонецЦикла;
	
КонецПроцедуры

// Снимает один элемент условного оформления, если это список значений.
// 
// Параметры:
//  УсловноеОформление - условное оформление элемента формы;
//  ИдентификаторПользовательскойНастройки - строка - идентификатор настройки;
//  Значение - значение, которое требуется удалить из списка оформления.
//
Процедура СнятьУсловноеОформлениеСпискаЗначений(
						УсловноеОформление,
						знач ИдентификаторПользовательскойНастройки,
						знач Значение) Экспорт
	
	Для каждого ЭлементУО Из УсловноеОформление.Элементы Цикл
		Если ЭлементУО.ИдентификаторПользовательскойНастройки = ИдентификаторПользовательскойНастройки Тогда
			Если ЭлементУО.Отбор.Элементы.Количество() = 0 Тогда
				Возврат;
			КонецЕсли;
			ЭлементСписокОтбора = ЭлементУО.Отбор.Элементы[0];
			Если ЭлементСписокОтбора.ПравоеЗначение = Неопределено Тогда
				Возврат;
			КонецЕсли;
			ЭлементСписка = ЭлементСписокОтбора.ПравоеЗначение.НайтиПоЗначению(Значение);
			Если ЭлементСписка <> Неопределено Тогда
				ЭлементСписокОтбора.ПравоеЗначение.Удалить(ЭлементСписка);
			КонецЕсли;
			ЭлементСписокОтбора.ПравоеЗначение = ЭлементСписокОтбора.ПравоеЗначение;
			Возврат;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Удаляет все вхождения переданного значения из массива.
//
// Параметры:
//  Массив - массив, из которого необходимо удалить значение;
//  Значение - удаляемое значение из массива.
// 
Процедура УдалитьВсеВхожденияЗначенияИзМассива(Массив, Значение) Экспорт
	
	КолвоЭлементовКоллекции = Массив.Количество();
	
	Для ОбратныйИндекс = 1 По КолвоЭлементовКоллекции Цикл
		
		Индекс = КолвоЭлементовКоллекции - ОбратныйИндекс;
		
		Если Массив[Индекс] = Значение Тогда
			
			Массив.Удалить(Индекс);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Удаляет все вхождения значений указанного типа.
//
// Параметры:
//  Массив - массив, из которого необходимо удалить значения;
//  Тип – тип значений, которые подлежат удалиению из массива.
// 
Процедура УдалитьВсеВхожденияТипаИзМассива(Массив, Тип) Экспорт
	
	КолвоЭлементовКоллекции = Массив.Количество();
	
	Для ОбратныйИндекс = 1 По КолвоЭлементовКоллекции Цикл
		
		Индекс = КолвоЭлементовКоллекции - ОбратныйИндекс;
		
		Если ТипЗнч(Массив[Индекс]) = Тип Тогда
			
			Массив.Удалить(Индекс);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Удаляет одно значение из массива.
//
// Параметры:
//  Массив - массив, из которого необходимо удалить значение;
//  Значение - удаляемое значение из массива.
// 
Процедура УдалитьЗначениеИзМассива(Массив, Значение) Экспорт
	
	Индекс = Массив.Найти(Значение);
	
	Если Индекс <> Неопределено Тогда
		
		Массив.Удалить(Индекс);
		
	КонецЕсли;
	
КонецПроцедуры

// Заполняет коллекцию-приемник значениями из коллекции-источник
// В качестве коллекций источника и приемника могут выступать типы:
// ТаблицаЗначений; ДеревоЗначений; СписокЗначений и пр.
//
// Параметры:
//  КоллекцияИсточник - коллекция значений, которая является источником для заполнения данных;
//  КоллекцияПриемник - коллекция значений, которая является приемником для заполнения данных.
// 
Процедура ЗаполнитьКоллекциюСвойств(КоллекцияИсточник, КоллекцияПриемник) Экспорт
	
	Для Каждого Элемент ИЗ КоллекцияИсточник Цикл
		
		ЗаполнитьЗначенияСвойств(КоллекцияПриемник.Добавить(), Элемент);
		
	КонецЦикла;
	
КонецПроцедуры

// Получает массив значений из отмеченных элементов списка значений.
//
// Параметры:
//  Список - СписокЗначений - список значений из которого будет формироваться массив значений;
// 
// Возвращаемое значение:
//  Массив - массив значений из отмеченных элементов списка значений.
//
Функция ПолучитьМассивОтмеченныхЭлементовСписка(Список) Экспорт
	
	// возвращаемое значение функции
	Массив = Новый Массив;
	
	Для Каждого Элемент ИЗ Список Цикл
		
		Если Элемент.Пометка Тогда
			
			Массив.Добавить(Элемент.Значение);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Массив;
КонецФункции

// Вычитает один массив элементов из другого массива. Возвращает результат вычитания.
//
// Параметры:
//  Массив - массив элементов, из которого необходимо выполнить вычитание;
//  МассивВычитания - массив элементов, который будет вычитаться.
// 
// Возвращаемое значение:
//  Массив – результат вычитания двух массивов.
//
Функция СократитьМассив(Массив, МассивВычитания) Экспорт
	
	Результат = Новый Массив;
	
	Для Каждого Элемент Из Массив Цикл
		
		Если МассивВычитания.Найти(Элемент) = Неопределено Тогда
			
			Результат.Добавить(Элемент);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Преобразует РасписаниеРегламентногоЗадания в структуру.
//
// Параметры:
//  Расписание - РасписаниеРегламентногоЗадания;
// 
// Возвращаемое значение:
//  Структура.
//
Функция РасписаниеВСтруктуру(Знач Расписание) Экспорт
	
	ЗначениеРасписания = Расписание;
	Если ЗначениеРасписания = Неопределено Тогда
		ЗначениеРасписания = Новый РасписаниеРегламентногоЗадания();
	КонецЕсли;
	СписокПолей = "ВремяЗавершения,ВремяКонца,ВремяНачала,ДатаКонца,ДатаНачала,ДеньВМесяце,ДеньНеделиВМесяце," + 
		"ДниНедели,ИнтервалЗавершения,Месяцы,ПаузаПовтора,ПериодНедель,ПериодПовтораВТечениеДня,ПериодПовтораДней";
	Результат = Новый Структура(СписокПолей);
	ЗаполнитьЗначенияСвойств(Результат, ЗначениеРасписания, СписокПолей);
	ДетальныеРасписанияДня = Новый Массив;
	Для каждого РасписаниеДля Из Расписание.ДетальныеРасписанияДня Цикл
		ДетальныеРасписанияДня.Добавить(РасписаниеВСтруктуру(РасписаниеДля));
	КонецЦикла;
	Результат.Вставить("ДетальныеРасписанияДня", ДетальныеРасписанияДня);
	Возврат Результат;
	
КонецФункции		

// Преобразует структуру в РасписаниеРегламентногоЗадания.
//
// Параметры:
//  СтруктураРасписания - Структура;
// 
// Возвращаемое значение:
//  РасписаниеРегламентногоЗадания.
//
Функция СтруктураВРасписание(Знач СтруктураРасписания) Экспорт
	
	Если СтруктураРасписания = Неопределено Тогда
		Возврат Новый РасписаниеРегламентногоЗадания();
	КонецЕсли;
	СписокПолей = "ВремяЗавершения,ВремяКонца,ВремяНачала,ДатаКонца,ДатаНачала,ДеньВМесяце,ДеньНеделиВМесяце," + 
		"ДниНедели,ИнтервалЗавершения,Месяцы,ПаузаПовтора,ПериодНедель,ПериодПовтораВТечениеДня,ПериодПовтораДней";
	Результат = Новый РасписаниеРегламентногоЗадания;
	ЗаполнитьЗначенияСвойств(Результат, СтруктураРасписания, СписокПолей);
	ДетальныеРасписанияДня = Новый Массив;
	Для каждого Расписание Из СтруктураРасписания.ДетальныеРасписанияДня Цикл
		  ДетальныеРасписанияДня.Добавить(СтруктураВРасписание(Расписание));
	КонецЦикла;
	Результат.ДетальныеРасписанияДня = ДетальныеРасписанияДня;  
	Возврат Результат;
	
КонецФункции		

// Создает копию экземпляра указанного объекта.
//
// Параметры:
//  Источник - Произвольный - объект, который необходимо скопировать.
//
// Возвращаемое значение:
//  Произвольный - копия объекта, переданного в параметре Источник.
//
// Примечание:
//  Функцию нельзя использовать для объектных типов (СправочникОбъект, ДокументОбъект и т.п.).
Функция СкопироватьРекурсивно(Источник) Экспорт
	
	Перем Приемник;
	
	ТипИсточника = ТипЗнч(Источник);
	Если ТипИсточника = Тип("Структура") Тогда
		Приемник = СкопироватьСтруктуру(Источник);
	ИначеЕсли ТипИсточника = Тип("Соответствие") Тогда
		Приемник = СкопироватьСоответствие(Источник);
	ИначеЕсли ТипИсточника = Тип("Массив") Тогда
		Приемник = СкопироватьМассив(Источник);
	ИначеЕсли ТипИсточника = Тип("СписокЗначений") Тогда
		Приемник = СкопироватьСписокЗначений(Источник);
	#Если Сервер Или ТолстыйКлиент Или ВнешнееСоединение Тогда
	ИначеЕсли ТипИсточника = Тип("ТаблицаЗначений") Тогда
		Приемник = Источник.Скопировать();
	#КонецЕсли
	Иначе
		Приемник = Источник;
	КонецЕсли;
	
	Возврат Приемник;
	
КонецФункции

// Создает копию значения типа Структура.
//
// Параметры:
//  СтруктураИсточник – Структура – копируемая структура.
// 
// Возвращаемое значение:
//  Структура - копия исходной структуры.
//
Функция СкопироватьСтруктуру(СтруктураИсточник) Экспорт
	
	СтруктураРезультат = Новый Структура;
	
	Для Каждого КлючИЗначение ИЗ СтруктураИсточник Цикл
		СтруктураРезультат.Вставить(КлючИЗначение.Ключ, СкопироватьРекурсивно(КлючИЗначение.Значение));
	КонецЦикла;
	
	Возврат СтруктураРезультат;
	
КонецФункции

// Создает копию значения типа Соответствие.
//
// Параметры:
//  СоответствиеИсточник – Соответствие - соответствие, копию которого необходимо получить.
// 
// Возвращаемое значение:
//  Соответствие - копия исходного соответствия.
//
Функция СкопироватьСоответствие(СоответствиеИсточник) Экспорт
	
	СоответствиеРезультат = Новый Соответствие;
	
	Для Каждого КлючИЗначение ИЗ СоответствиеИсточник Цикл
		СоответствиеРезультат.Вставить(КлючИЗначение.Ключ, СкопироватьРекурсивно(КлючИЗначение.Значение));
	КонецЦикла;
	
	Возврат СоответствиеРезультат;

КонецФункции

// Создает копию значения типа Массив.
//
// Параметры:
//  МассивИсточник – Массив - массив, копию которого необходимо получить.
// 
// Возвращаемое значение:
//  Массив - копия исходного массива.
//
Функция СкопироватьМассив(МассивИсточник) Экспорт
	
	МассивРезультат = Новый Массив;
	
	Для Каждого Элемент ИЗ МассивИсточник Цикл
		МассивРезультат.Добавить(СкопироватьРекурсивно(Элемент));
	КонецЦикла;
	
	Возврат МассивРезультат;
	
КонецФункции

// Создает копию значения типа СписокЗначений.
//
// Параметры:
//  СписокИсточник – СписокЗначений - список значений, копию которого необходимо получить.
// 
// Возвращаемое значение:
//  СписокЗначений - копия исходного списка зачений.
//
Функция СкопироватьСписокЗначений(СписокИсточник) Экспорт
	
	СписокРезультат = Новый СписокЗначений;
	
	Для Каждого ЭлементСписка ИЗ СписокИсточник Цикл
		СписокРезультат.Добавить(
			СкопироватьРекурсивно(ЭлементСписка.Значение), 
			ЭлементСписка.Представление, 
			ЭлементСписка.Пометка, 
			ЭлементСписка.Картинка);
	КонецЦикла;
	
	Возврат СписокРезультат;
	
КонецФункции
	
// Сравнивает элементы списков значений или массивов по значениям
//
Функция СпискиЗначенийИдентичны(Список1, Список2) Экспорт
	
	СпискиИдентичны = Истина;
	
	Для Каждого ЭлементСписка1 Из Список1 Цикл
		Если НайтиВСписке(Список2, ЭлементСписка1) = Неопределено Тогда
			СпискиИдентичны = Ложь;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если СпискиИдентичны Тогда
		Для Каждого ЭлементСписка2 Из Список2 Цикл
			Если НайтиВСписке(Список1, ЭлементСписка2) = Неопределено Тогда
				СпискиИдентичны = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат СпискиИдентичны;
	
КонецФункции // СпискиЗначенийИдентичны

// Создает массив и помещает в него переданное значение
//
Функция ЗначениеВМассиве(Значение) Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(Значение);
	
	Возврат Массив;
	
КонецФункции

// Процедура управляет состояние поля табличного документа
//
//Параметры:
//  ПолеТабличногоДокумента – ПолеФормы – поле формы с видом ПолеТабличногоДокумента,
//                            для которого необходимо установить состояние.
//  Состояние               – Строка – задает вид состояния.
//
Процедура УстановитьСостояниеПоляТабличногоДокумента(ПолеТабличногоДокумента, Состояние = "НеИспользовать") Экспорт
	
	Если ТипЗнч(ПолеТабличногоДокумента) = Тип("ПолеФормы") 
		И ПолеТабличногоДокумента.Вид = ВидПоляФормы.ПолеТабличногоДокумента Тогда
		ОтображениеСостояния = ПолеТабличногоДокумента.ОтображениеСостояния;
		Если ВРег(Состояние) = "НЕИСПОЛЬЗОВАТЬ" Тогда
			ОтображениеСостояния.Видимость                      = Ложь;
			ОтображениеСостояния.ДополнительныйРежимОтображения = ДополнительныйРежимОтображения.НеИспользовать;
			ОтображениеСостояния.Картинка                       = Новый Картинка;
			ОтображениеСостояния.Текст                          = "";
		ИначеЕсли ВРег(Состояние) = "НЕАКТУАЛЬНОСТЬ" Тогда
			ОтображениеСостояния.Видимость                      = Истина;
			ОтображениеСостояния.ДополнительныйРежимОтображения = ДополнительныйРежимОтображения.Неактуальность;
			ОтображениеСостояния.Картинка                       = Новый Картинка;
			ОтображениеСостояния.Текст                          = НСтр("ru = 'Отчет не сформирован. Нажмите ""Сформировать"" для получения отчета.'");;
		ИначеЕсли ВРег(Состояние) = "ФОРМИРОВАНИЕОТЧЕТА" Тогда  
			ОтображениеСостояния.Видимость                      = Истина;
			ОтображениеСостояния.ДополнительныйРежимОтображения = ДополнительныйРежимОтображения.Неактуальность;
			ОтображениеСостояния.Картинка                       = БиблиотекаКартинок.ДлительнаяОперация48;
			ОтображениеСостояния.Текст                          = НСтр("ru = 'Отчет формируется...'");
		Иначе
			ВызватьИсключение(НСтр("ru = 'Недопустимое значение параметра (параметр номер ''2'')'"));
		КонецЕсли;
	Иначе
		ВызватьИсключение(НСтр("ru = 'Недопустимое значение параметра (параметр номер ''1'')'"));
	КонецЕсли;
	
КонецПроцедуры

// Получает номер версии конфигурации без номера сборки
//
// Параметры:
//  Версия - Строка - версия конфигурации в формате РР.ПП.ЗЗ.СС,
//                    где СС – номер сборки, который будет удален
// 
//  Возвращаемое значение:
//  Строка - номер версии конфигурации без номера сборки в формате РР.ПП.ЗЗ
//
Функция ВерсияКонфигурацииБезНомераСборки(Знач Версия) Экспорт
	
	Массив = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Версия, ".");
	
	Если Массив.Количество() < 3 Тогда
		Возврат Версия;
	КонецЕсли;
	
	Результат = "[Редакция].[Подредакция].[Релиз]";
	Результат = СтрЗаменить(Результат, "[Редакция]",    Массив[0]);
	Результат = СтрЗаменить(Результат, "[Подредакция]", Массив[1]);
	Результат = СтрЗаменить(Результат, "[Релиз]",       Массив[2]);
	
	Возврат Результат;
КонецФункции

// Сравнить две строки версий.
//
// Параметры
//  СтрокаВерсии1  – Строка – номер версии в формате РР.{П|ПП}.ЗЗ.СС
//  СтрокаВерсии2  – Строка – второй сравниваемый номер версии
//
// Возвращаемое значение:
//   Число   – больше 0, если СтрокаВерсии1 > СтрокаВерсии2; 0, если версии равны.
//
Функция СравнитьВерсии(Знач СтрокаВерсии1, Знач СтрокаВерсии2) Экспорт
	
	Строка1 = ?(ПустаяСтрока(СтрокаВерсии1), "0.0.0.0", СтрокаВерсии1);
	Строка2 = ?(ПустаяСтрока(СтрокаВерсии2), "0.0.0.0", СтрокаВерсии2);
	Версия1 = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Строка1, ".");
	Если Версия1.Количество() <> 4 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		                    НСтр("ru = 'Неправильный формат строки версии: %1'"), СтрокаВерсии1);
	КонецЕсли;
	Версия2 = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Строка2, ".");
	Если Версия2.Количество() <> 4 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
	                         НСтр("ru = 'Неправильный формат строки версии: %1'"), СтрокаВерсии2);
	КонецЕсли;
	
	Результат = 0;
	Для Разряд = 0 По 3 Цикл
		Результат = Число(Версия1[Разряд]) - Число(Версия2[Разряд]);
		Если Результат <> 0 Тогда
			Возврат Результат;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с файлами
//

// Процедура УдалитьКаталогСФайлами удаляет все файлы в заданном каталоге.
//
// Параметры:
//  Путь         - Строка, полный путь каталога, в котором требуется
//                 удалить все файлы.
//
Процедура УдалитьКаталогСФайлами(Путь) Экспорт
	
	Каталог = Новый Файл(Путь);
	
	#Если Клиент Тогда
		Каталог.НачатьПроверкуСуществования(Новый ОписаниеОповещения("УдалитьКаталогСФайламиЗавершение", ЭтотОбъект, Новый Структура("Путь", Путь)));
	#Иначе
		УдалитьФайлы(Путь);
	#КонецЕслИ
	
КонецПроцедуры

&НаКлиенте
Процедура УдалитьКаталогСФайламиЗавершение(Существует, ДополнительныеПараметры) Экспорт
	
	Путь = ДополнительныеПараметры.Путь;
	
	
	Если Существует Тогда
		НачатьУдалениеФайлов(Неопределено, Путь);
	КонецЕсли;

КонецПроцедуры // УдалитьКаталогСФайлами()

// Добавляет к переданному пути каталога конечный символ-разделитель, если он отсутствует.
// В случае, когда параметр "Платформа" не указан, разделитель выбирается, исходя из уже имеющихся
// разделителей в параметре "ПутьКаталога".
//
// Параметры:
//  ПутьКаталога - Строка - путь к каталогу;
//  Платформа - ТипПлатформы - тип платформы, в рамках которой осуществляется работа (влияет на выбор разделителя).
//
// Возвращаемое значение:
//  Строка   - путь к каталогу с конечным символом-разделителем.
//
// Примеры использования:
//  Результат = ДобавитьКонечныйРазделительПути("C:\Мой каталог"); // возвращает "C:\Мой каталог\"
//  Результат = ДобавитьКонечныйРазделительПути("C:\Мой каталог\"); // возвращает "C:\Мой каталог\"
//  Результат = ДобавитьКонечныйРазделительПути("ftp://Мой каталог"); // возвращает "ftp://Мой каталог/"
//	Результат = ДобавитьКонечныйРазделительПути("%APPDATA%", ТипПлатформы.Windows_x86_64); // возвращает "%APPDATA%\"
//
Функция ДобавитьКонечныйРазделительПути(Знач ПутьКаталога, Знач Платформа = Неопределено) Экспорт
	
	Если ПустаяСтрока(ПутьКаталога) Тогда
		Возврат ПутьКаталога;
	КонецЕсли;
	
	ДобавляемыйСимвол = "\";
	Если Платформа = Неопределено Тогда
		Если Найти(ПутьКаталога, "/") > 0 Тогда
			ДобавляемыйСимвол = "/";
		КонецЕсли;
	Иначе
		Если Платформа = ТипПлатформы.Linux_x86 Или Платформа = ТипПлатформы.Linux_x86_64 Тогда
			ДобавляемыйСимвол = "/";
		КонецЕсли;
	КонецЕсли;
	
	Если Прав(ПутьКаталога, 1) <> ДобавляемыйСимвол Тогда
		Возврат ПутьКаталога + ДобавляемыйСимвол;
	Иначе 
		Возврат ПутьКаталога;
	КонецЕсли;
	
КонецФункции

// Составляет полное имя файла из имени каталога и имени файла.
//
// Параметры
//  ИмяКаталога  – Строка, содержащая путь к каталогу файла на диске.
//  ИмяФайла     – Строка, содержащая имя файла, без имени каталога.
//
// Возвращаемое значение:
//   Строка – полное имя файла с учетом каталога.
//
Функция ПолучитьПолноеИмяФайла(Знач ИмяКаталога, Знач ИмяФайла) Экспорт

	Если НЕ ПустаяСтрока(ИмяФайла) Тогда
		
		Слэш = "";
		Если (Прав(ИмяКаталога, 1) <> "\") И (Прав(ИмяКаталога, 1) <> "/") Тогда
			Слэш = ?(Найти(ИмяКаталога, "\") = 0, "/", "\");
		КонецЕсли;
		
		Возврат ИмяКаталога + Слэш + ИмяФайла;
		
	Иначе
		
		Возврат ИмяКаталога;
		
	КонецЕсли;

КонецФункции

// Раскладывает полное имя файла на составляющие.
//
// Параметры
//  ПолноеИмяФайла – Строка, содержащая полный путь к файлу.
//  ЭтоПапка – Булево, признак того, что требуется разложить полное имя папки, а не файла.
//
// Возвращаемое значение:
//   Структура – имя файла, разложенное на составные части(аналогично свойствам объекта Файл):
//		ПолноеИмя - Содержит полный путь к файлу, т.е. полностью соответствует входному параметру ПолноеИмяФайла.
//		Путь - Содержит путь к каталогу, в котором лежит файл.
//		Имя - Содержит имя файла с расширением, без пути к файлу.
//		Расширение - Содержит расширение файла
//		ИмяБезРасширения - Содержит имя файла без расширения и без пути к файлу.
//			Пример: если ПолноеИмяФайла = "c:\temp\test.txt", то структура заполнится следующим образом:
//				ПолноеИмя: "c:\temp\test.txt"
//				Путь: "c:\temp\"
//				Имя: "test.txt"
//				Расширение: ".txt"
//				ИмяБезРасширения: "test"
//
Функция РазложитьПолноеИмяФайла(Знач ПолноеИмяФайла, ЭтоПапка = Ложь) Экспорт
	
	СтруктураИмениФайла = Новый Структура("ПолноеИмя,Путь,Имя,Расширение,ИмяБезРасширения");
	
	// Убераем из полного имени файла завершающий слеш и сохраняем получившееся полное имя в структуре
	Если ЭтоПапка И (Прав(ПолноеИмяФайла, 1) = "/" Или Прав(ПолноеИмяФайла, 1) = "\") Тогда
		Если ЭтоПапка Тогда
			ПолноеИмяФайла = Сред(ПолноеИмяФайла, 1, СтрДлина(ПолноеИмяФайла) - 1);
		Иначе
			// Если путь к файлу заканчивается слешем, то у файла нет имени.
			СтруктураИмениФайла.Вставить("ПолноеИмя", ПолноеИмяФайла); 
			СтруктураИмениФайла.Вставить("Путь", ПолноеИмяФайла); 
			СтруктураИмениФайла.Вставить("Имя", ""); 
			СтруктураИмениФайла.Вставить("Расширение", ""); 
			СтруктураИмениФайла.Вставить("ИмяБезРасширения", ""); 
			Возврат СтруктураИмениФайла;
		КонецЕсли;
	КонецЕсли;
	СтруктураИмениФайла.Вставить("ПолноеИмя", ПолноеИмяФайла); 
	
	// Если полное имя файла оказалось пустым - то остальные параметры структуры возвращаем пустыми
	Если СтрДлина(ПолноеИмяФайла) = 0 Тогда 
		СтруктураИмениФайла.Вставить("Путь", ""); 
		СтруктураИмениФайла.Вставить("Имя", ""); 
		СтруктураИмениФайла.Вставить("Расширение", ""); 
		СтруктураИмениФайла.Вставить("ИмяБезРасширения", ""); 
		Возврат СтруктураИмениФайла;
	КонецЕсли;
	
	// Выделяем путь к файлу и имя файла									 
	Если Найти(ПолноеИмяФайла, "/") > 0 Тогда
		ПозицияРазделителя = СтроковыеФункцииКлиентСервер.НайтиСимволСКонца(ПолноеИмяФайла, "/");
	ИначеЕсли Найти(ПолноеИмяФайла, "\") > 0 Тогда
		ПозицияРазделителя = СтроковыеФункцииКлиентСервер.НайтиСимволСКонца(ПолноеИмяФайла, "\");
	Иначе
		ПозицияРазделителя = 0;
	КонецЕсли;
	СтруктураИмениФайла.Вставить("Путь", Лев(ПолноеИмяФайла, ПозицияРазделителя)); 
	СтруктураИмениФайла.Вставить("Имя", Сред(ПолноеИмяФайла, ПозицияРазделителя + 1));
	
	// Папки не имеют расширений, а для файла выделяем расширение
	Если ЭтоПапка Тогда
		СтруктураИмениФайла.Вставить("Расширение", "");
		СтруктураИмениФайла.Вставить("ИмяБезРасширения", СтруктураИмениФайла.Имя);
	Иначе
        ПозицияТочки = СтроковыеФункцииКлиентСервер.НайтиСимволСКонца(СтруктураИмениФайла.Имя, ".");
		Если ПозицияТочки = 0 Тогда
			СтруктураИмениФайла.Вставить("Расширение", "");
			СтруктураИмениФайла.Вставить("ИмяБезРасширения", СтруктураИмениФайла.Имя);
		Иначе
			СтруктураИмениФайла.Вставить("Расширение", Сред(СтруктураИмениФайла.Имя, ПозицияТочки));
			СтруктураИмениФайла.Вставить("ИмяБезРасширения", Лев(СтруктураИмениФайла.Имя, ПозицияТочки - 1));
		КонецЕсли;
	КонецЕсли;
	
	Возврат СтруктураИмениФайла;
	
КонецФункции

// Возвращает строку недопустимых символов
// Согласно http://en.wikipedia.org/wiki/Filename - в разделе "Reserved characters and words"
// Возвращаемое значение:
//   Строка - строка недопустимых символов
Функция ПолучитьНедопустимыеСимволыВИмениФайла() Экспорт

	НедопустимыеСимволы = """/\[]:;|=?*<>";
	Возврат НедопустимыеСимволы;

КонецФункции

// Проверяет наличение недопустимых символов в имени файла
//
// Параметры
//  ИмяФайла  - Строка 
// Возвращаемое значение:
//   Массив   - массив обнаруженных в имени файла недопустимых символов.
//              Если недопустимых символов не обнаружено возвращается пустой массив.
Функция НайтиНедопустимыеСимволыВИмениФайла(ИмяФайла) Экспорт

	НедопустимыеСимволы = ПолучитьНедопустимыеСимволыВИмениФайла();
	
	МассивНайденныхНедопустимыхСимволов = Новый Массив;
	
	Для ПозицияСимвола = 1 По СтрДлина(НедопустимыеСимволы) Цикл
		ПроверяемыйСимвол = Сред(НедопустимыеСимволы,ПозицияСимвола,1);
		Если Найти(ИмяФайла,ПроверяемыйСимвол) <> 0 Тогда
			МассивНайденныхНедопустимыхСимволов.Добавить(ПроверяемыйСимвол);
		КонецЕсли;
	КонецЦикла;
	
	Возврат МассивНайденныхНедопустимыхСимволов;

КонецФункции

// Заменяет недопустимые символы в имени файла
//
// Параметры
//  ИмяФайла     - Строка - исходное имя файла.
//  НаЧтоМенять  - Строка - строка на которые неоходимо заменить недопустимые символы.
//
// Возвращаемое значение:
//   Строка   - имя файла в котором недопустимые символы заменены.
//
Функция ЗаменитьНедопустимыеСимволыВИмениФайла(Знач ИмяФайла, НаЧтоМенять = " ") Экспорт

	Результат = ИмяФайла;
	МассивНайденныхНедопустимыхСимволов = НайтиНедопустимыеСимволыВИмениФайла(Результат);
	Для Каждого НедопустимыйСимвол Из МассивНайденныхНедопустимыхСимволов Цикл
		Результат = СтрЗаменить(Результат, НедопустимыйСимвол, НаЧтоМенять);
	КонецЦикла;
	
	Возврат Результат;

КонецФункции

// Преобразует расширение файла в нижний регистр без точки.
//
// Параметры:
//  Расширение - Строка. Расширение для преобразования.
//
// Возвращаемое значение:
//  Строка.
//
Функция РасширениеБезТочки(Знач Расширение) Экспорт
	
	Расширение = НРег(СокрЛП(Расширение));
	
	Если Сред(Расширение, 1, 1) = "." Тогда
		Расширение = Сред(Расширение, 2);
	КонецЕсли;
	
	Возврат Расширение;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с почтовыми адресами
//

// Разбирает строку с адресами электронной почты согласно стандарту RFC 5322 с ограничениями.
//
// Ограничения:
//  1. В адресе разрешаются только буквы, цифры, символ подчеркивания, дефис и символ "@".
//  2. Символы скобок "<>[]()" допускаются, но игнорируются путём замены на пробелы.
//  3. Группы запрещены.
//
// Параметры:
//  Строка - Строка - Строка, содержащая электронные адреса (mailbox-list).
//
// Возвращаемое значение:
//  Массив - содержит массив структур адресов.
//           Поля структуры:
//             Псевдоним      - Строка - представление адресата.
//             Адрес          - Строка - найденный и соответствующий требованиям почтовый адрес;
//                                       Если текст, похожий на адрес найден, но не соответствует требованиям
//                                       стандартов, то такой текст записывается в поле "Псевдоним".
//             ОписаниеОшибки - Строка - текстовое представление ошибки, либо пустая строка, если ошибок нет.
Функция АдресаЭлектроннойПочтыИзСтроки(Знач Строка) Экспорт
	
	Результат = Новый Массив;
	
	// заменяем скобки на пробелы
	СимволыСкобок = "<>()[]";
	Строка = ЗаменитьСимволыВСтрокеНаПробелы(Строка, СимволыСкобок);
	
	// приводим разделители к одному виду
	Строка = СтрЗаменить(Строка, ",", ";");
	
	// раскладываем mailbox-list на mailbox'ы
	МассивАдресов = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Строка, ";", Истина);
	
	// допустимые символы для псевдонима (display-name)
	Буквы = "abcdefghijklmnopqrstuvwxyzабвгдеёжзийклмнопрстуфхцчшщъыьэюя";
	Цифры = "0123456789";
	ДополнительныеСимволы = "._- ";
	
	// выделяем из строки адреса (mailbox'а) псевдоним (display-name) и адрес (addr-spec)
	Для Каждого СтрокаАдреса Из МассивАдресов Цикл
		
		Псевдоним = "";
		Адрес = "";
		ОписаниеОшибки = "";
		
		Если СтрЧислоВхождений(СтрокаАдреса, "@") <> 1 Тогда
			Псевдоним = СтрокаАдреса;
		Иначе
			// всё, что не подходит в качестве адреса, складываем в псевдоним
			Для Каждого Подстрока Из СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрокаАдреса, " ") Цикл
				Если ПустаяСтрока(Адрес) и АдресЭлектроннойПочтыСоответствуетТребованиям(Подстрока) Тогда
					Адрес = Подстрока;
				Иначе
					Псевдоним = Псевдоним + " " + Подстрока;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		Псевдоним = СокрЛП(Псевдоним);
		
		// проверки
		ЕстьНедопустимыеСимволыВПсевдониме = Не СтрокаСодержитТолькоДопустимыеСимволы(НРег(Псевдоним), Буквы + Цифры + ДополнительныеСимволы);
		АдресОпределен = Не ПустаяСтрока(Адрес);
		ЕстьПризнакНаличияАдресаВСтроке = СтрНайти(СтрокаАдреса, "@") > 0;
		
		Если АдресОпределен Тогда 
			Если ЕстьНедопустимыеСимволыВПсевдониме Тогда
				ОписаниеОшибки = НСтр("ru = 'Представление содержит недопустимые символы'");
			КонецЕсли;
		Иначе
			Если ЕстьПризнакНаличияАдресаВСтроке Тогда 
				ОписаниеОшибки = НСтр("ru = 'Адрес электронной почты содержит ошибки'");
			Иначе
				ОписаниеОшибки = НСтр("ru = 'Строка не содержит адреса электронной почты'");
			КонецЕсли;
		КонецЕсли;	
		
		СтруктураАдреса = Новый Структура("Псевдоним,Адрес,ОписаниеОшибки", Псевдоним, Адрес, ОписаниеОшибки);
		Результат.Добавить(СтруктураАдреса);
	КонецЦикла;
	
	Возврат Результат;	
	
КонецФункции

// Проверяет email адрес на соответствие требованиям стандартов RFC 5321, RFC 5322,
// а также RFC 5335, RFC 5336 и RFC 3696.
// Кроме того, функция ограничивает использование спецсимволов.
// 
// Параметры:
//  Адрес - Строка - проверяемый email.
//
// Возвращаемое значение:
//  Булево - Истина, если ошибок нет.
//
Функция АдресЭлектроннойПочтыСоответствуетТребованиям(Знач Адрес) Экспорт
	
	// допустимые символы для email
	Буквы = "abcdefghijklmnopqrstuvwxyzабвгдеёжзийклмнопрстуфхцчшщъыьэюя";
	Цифры = "0123456789";
	СпецСимволы = ".@_-";
	
	// проверяем любые сочетания спецсимволов
	Если СтрДлина(СпецСимволы) > 1 Тогда
		Для Позиция1 = 1 По СтрДлина(СпецСимволы)-1 Цикл
			Символ1 = Сред(СпецСимволы, Позиция1, 1);
			Для Позиция2 = Позиция1 + 1 По СтрДлина(СпецСимволы) Цикл
				Символ2 = Сред(СпецСимволы, Позиция2, 1);
				Комбинация1 = Символ1 + Символ2;
				Комбинация2 = Символ2 + Символ1;
				Если Найти(Адрес, Комбинация1) > 0 или Найти(Адрес, Комбинация2) > 0 Тогда
					Возврат Ложь;
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
	КонецЕсли;
	
	// проверяем символ @
	Если СтрЧислоВхождений(Адрес, "@") <> 1 Тогда
		Возврат Ложь;
	КонецЕсли;
	   
	// проверяем две точки подряд
	Если Найти(Адрес, "..") > 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// приводим строку адреса к нижнему регистру
	Адрес = НРег(Адрес);
	
	// проверяем допустимые символы
	Если Не СтрокаСодержитТолькоДопустимыеСимволы(Адрес, Буквы + Цифры + СпецСимволы) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// разбираем адрес на local-part и domain
	Позиция = СтрНайти(Адрес,"@");
	ЛокальноеИмя = Лев(Адрес, Позиция - 1);
	Домен = Сред(Адрес, Позиция + 1);
	
	// проверяем на заполненность и допустимость длины
	Если ПустаяСтрока(ЛокальноеИмя)
	 	или ПустаяСтрока(Домен)
		или СтрДлина(ЛокальноеИмя) > 64
		или СтрДлина(Домен) > 255 Тогда
		
		Возврат Ложь;
	КонецЕсли;
	
	// проверяем наличие спецсимволов в начале и в конце частей адреса
	Если ЕстьСимволыВНачалеВКонце(ЛокальноеИмя, СпецСимволы) или ЕстьСимволыВНачалеВКонце(Домен, СпецСимволы) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// в домене должна быть минимум одна точка
	Если Найти(Домен,".") = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// в домене не должно быть символа подчеркивания
	Если Найти(Домен,"_") > 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// выделяем зону (TLD) из имени домена 
	Зона = Домен;
	Позиция = СтрНайти(Зона,".");
	Пока Позиция > 0 Цикл
		Зона = Сред(Зона, Позиция + 1);
		Позиция = СтрНайти(Зона,".");
	КонецЦикла;
	
	// проверяем зону домена (минимум 2 символа, только буквы)
	Возврат СтрДлина(Зона) >= 2 и СтрокаСодержитТолькоДопустимыеСимволы(Зона,Буквы);
	
КонецФункции

// Функция проверяет что введенная строка с e-mail адресами введена правильно
//
// Формат строки:
// Z = ИмяПользователя|[Имя Пользователя] [<]пользователь@почтовый_сервер[>], Строка = Z[<разделитель*>Z]..
// 
//   прим.: разделитель* - имеется в виду любой разделитель адресов
//
// Параметры:
// СтрокаПереданныхАдресов - строка - правильная строка с почтовыми адресами
//
// Возвращаемое значение:
// Структура
// ключ Статус - булево - успех или неуспех преобразования
// в случае успеха содержит ключ Значение:
//           Массив структур, где
//                  Адрес- e-mail получателя
//                  Представление   - имя получателя
// в случае неуспеха содержит ключ СообщениеОбОшибке - строка
//
//  ВАЖНО: Функция возвращает массив структур, в которых одно поле (любое)
//         может быть незаполнено. Может использоваться различными
//         подсистемами для собственного сопоставления имени пользователя
//         некому e-mail адресу. Поэтому, необходимо перед непосредственной
//         отправкой проверить, что поле почтового адреса заполнено.
//
Функция РазобратьСтрокуСПочтовымиАдресами(знач СтрокаПереданныхАдресов) Экспорт
	
	Результат = Новый Массив;
	
	НедопустимыеСимволы = "!#$%^&*()+`~|\/=";
	
	СообщениеНедопустимыеСимволы = НСтр("ru = 'Недопустимый символ %1 в адресе электронной почты %2'");
	СообщениеНеверныйФорматПочтовогоАдреса = НСтр("ru = 'Некорректный адрес электронной почты %1'");
	
	МассивПодстрок = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрокаПереданныхАдресов,";",Истина);
	МассивПодстрокКОбработке = Новый Массив;
	
	Для каждого ЭлементМассива Из МассивПодстрок Цикл
		Если Найти(ЭлементМассива,",") > 0 Тогда
			ДопМассивПодстрок = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрокаПереданныхАдресов);
			Для каждого ЭлементДопМассива Из ДопМассивПодстрок Цикл
				МассивПодстрокКОбработке.Добавить(ЭлементДопМассива);
			КонецЦикла;
		Иначе
			МассивПодстрокКОбработке.Добавить(ЭлементМассива);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого СтрокаАдреса ИЗ МассивПодстрокКОбработке Цикл
		
		Индекс = 1;               // номер обрабатываемого символа
		Накопитель = "";          // накопитель символов, после анализа перемещается либо в полное имя
		// либо в почтовый адрес
		ПолноеИмяАдресата = "";   // переменная, накапливающая имя адресата
		ПочтовыйАдрес = "";       // переменная, накапливающая e-mail адрес
		// 1 - формирование полного имени: ожидаются любые допустимые символы имени адресата
		// 2 - формирование почтового адреса: ожидаются любые допустимые символы email адреса
		// 3 - завершение формирования очередного почтового адреса - ожидаются символы разделители либо пробелы
		СтадияРазбора = 1; 
		
		Пока Индекс <= СтрДлина(СтрокаАдреса) Цикл
			
			Символ = Сред(СтрокаАдреса, Индекс, 1);
			
			Если      Символ = " " Тогда
				Индекс = ? ((ПропуститьПробелы(СтрокаАдреса, Индекс, " ") - 1) > Индекс,
				ПропуститьПробелы(СтрокаАдреса, Индекс, " ") - 1,
				Индекс);
				Если      СтадияРазбора = 1 Тогда
					ПолноеИмяАдресата = ПолноеИмяАдресата + Накопитель + " ";
				ИначеЕсли СтадияРазбора = 2 Тогда
					ПочтовыйАдрес = Накопитель;
					СтадияРазбора = 3;
				КонецЕсли;
				Накопитель = "";
			ИначеЕсли Символ = "@" Тогда
				Если      СтадияРазбора = 1 Тогда
					СтадияРазбора = 2;
					
					Для ИндексПоискаНС = 1 По СтрДлина(Накопитель) Цикл
						Если Найти(НедопустимыеСимволы, Сред(Накопитель, ИндексПоискаНС, 1)) > 0 Тогда
							ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
							                  СообщениеНедопустимыеСимволы,Сред(Накопитель, ИндексПоискаНС, 1),СтрокаАдреса);
						КонецЕсли;
					КонецЦикла;
					
					Накопитель = Накопитель + Символ;
				ИначеЕсли СтадияРазбора = 2 Тогда
					ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					                  СообщениеНеверныйФорматПочтовогоАдреса,СтрокаАдреса);
				ИначеЕсли СтадияРазбора = 3 Тогда
					ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					                  СообщениеНеверныйФорматПочтовогоАдреса,СтрокаАдреса);
				КонецЕсли;
			Иначе
				Если СтадияРазбора = 2 ИЛИ СтадияРазбора = 3 Тогда
					Если Найти(НедопустимыеСимволы, Символ) > 0 Тогда
						ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						                  СообщениеНедопустимыеСимволы,Символ,СтрокаАдреса);
					КонецЕсли;
				КонецЕсли;
				
				Накопитель = Накопитель + Символ;
			КонецЕсли;
			
			Индекс = Индекс + 1;
		КонецЦикла;
		
		Если      СтадияРазбора = 1 Тогда
			ПолноеИмяАдресата = ПолноеИмяАдресата + Накопитель;
		ИначеЕсли СтадияРазбора = 2 Тогда
			ПочтовыйАдрес = Накопитель;
		КонецЕсли;
		
		Если ПустаяСтрока(ПочтовыйАдрес) И (Не ПустаяСтрока(ПолноеИмяАдресата)) Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			                  СообщениеНеверныйФорматПочтовогоАдреса,ПолноеИмяАдресата);
		ИначеЕсли СтрЧислоВхождений(ПочтовыйАдрес,"@") <> 1 Тогда 
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			                  СообщениеНеверныйФорматПочтовогоАдреса,ПочтовыйАдрес);
		КонецЕсли;
		
		Если НЕ (ПустаяСтрока(ПолноеИмяАдресата) И ПустаяСтрока(ПочтовыйАдрес)) Тогда
			Результат.Добавить(ПроверитьИПодготовитьПочтовыйАдрес(ПолноеИмяАдресата, ПочтовыйАдрес));
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с отборами динамических списков
//

// Поиск элементов и групп отбора динамического списка
// Параметры:
//  ОбластьПоиска - контейнер с элементами и группами отбора, например
//                  Список.Отбор или группа в отборе
//  ИмяПоля - имя поля компоновки (не используется для групп)
//  Представление - представление поля компоновки
//  Примечание: поиск может осуществляться или по ЛевомуЗначению, или по Представлению
//
Функция НайтиЭлементыИГруппыОтбора(знач ОбластьПоиска,
									знач ИмяПоля = Неопределено,
									знач Представление = Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(ИмяПоля) Тогда
		ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
		СпособПоиска = 1;
	Иначе
		СпособПоиска = 2;
		ЗначениеПоиска = Представление;
	КонецЕсли;
	
	МассивЭлементов = Новый Массив;
	
	НайтиРекурсивно(ОбластьПоиска.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
	
	Возврат МассивЭлементов;
	
КонецФункции

// Добавление группы отбора
// Параметры:
//  КоллекцияЭлементов - контейнер с элементами и группами отбора, например
//                      Список.Отбор.Элементы или группа в отборе
//  ТипГруппы - ТипГруппыЭлементовОтбораКомпоновкиДанных - тип группы
//  Представление строка - представление группы
//
Функция СоздатьГруппуЭлементовОтбора(Знач КоллекцияЭлементов, Представление, ТипГруппы) Экспорт
	
	Если ТипЗнч(КоллекцияЭлементов) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
		КоллекцияЭлементов = КоллекцияЭлементов.Элементы;
	КонецЕсли;
	
	ГруппаЭлементовОтбора = НайтиЭлементОтбораПоПредставлению(КоллекцияЭлементов, Представление);
	Если ГруппаЭлементовОтбора = Неопределено Тогда
		ГруппаЭлементовОтбора = КоллекцияЭлементов.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
	Иначе
		ГруппаЭлементовОтбора.Элементы.Очистить();
	КонецЕсли;
	
	ГруппаЭлементовОтбора.Представление    = Представление;
	ГруппаЭлементовОтбора.Применение       = ТипПримененияОтбораКомпоновкиДанных.Элементы;
	ГруппаЭлементовОтбора.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
	ГруппаЭлементовОтбора.ТипГруппы        = ТипГруппы;
	ГруппаЭлементовОтбора.Использование    = Истина;
	
	Возврат ГруппаЭлементовОтбора;
	
КонецФункции

// Добавление элемента компоновки в контейнер элементов компоновки
// Параметры:
//  ОбластьДобавления - контейнер с элементами и группами отбора, например
//                  Список.Отбор или группа в отборе
//  ИмяПоля - строка - имя для поля компоновки данных
//  ВидСравнения - ВидСравненияКомпоновкиДанных - вид сравнения
//  ПравоеЗначение - произвольный
//  Представление - представление элемента компоновки данных
//  Использование - булево - использование элемента
//  РежимОтображения - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения
//
Функция ДобавитьЭлементКомпоновки(ОбластьДобавления,
									знач ИмяПоля,
									знач ВидСравнения,
									знач ПравоеЗначение = Неопределено,
									знач Представление  = Неопределено,
									знач Использование  = Неопределено,
									знач РежимОтображения = Неопределено) Экспорт
	
	Элемент = ОбластьДобавления.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Элемент.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПоля);
	Элемент.ВидСравнения = ВидСравнения;
	
	Если РежимОтображения = Неопределено Тогда
		Элемент.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
	Иначе
		Элемент.РежимОтображения = РежимОтображения;
	КонецЕсли;
	
	Если ПравоеЗначение <> Неопределено Тогда
		Элемент.ПравоеЗначение = ПравоеЗначение;
	КонецЕсли;
	
	Если Представление <> Неопределено Тогда
		Элемент.Представление = Представление;
	КонецЕсли;
	
	Если Использование <> Неопределено Тогда
		Элемент.Использование = Использование;
	КонецЕсли;
	
	Возврат Элемент;
	
КонецФункции

// Изменение элементов отбора
// Параметры
//  ИмяПоля - строка - имя поля компоновки
//  ВидСравнения - ВидСравненияКомпоновкиДанных - вид сравнения
//  ПравоеЗначение - произвольный
//  Представление - строка - представление элемента компоновки данных
//  Использование - булево - использование элемента
//  РежимОтображения - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения
//
Функция ИзменитьЭлементыОтбора(ОбластьПоиска,
								знач ИмяПоля = Неопределено,
								знач Представление = Неопределено,
								знач ПравоеЗначение = Неопределено,
								знач ВидСравнения = Неопределено,
								знач Использование = Неопределено,
								знач РежимОтображения = Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(ИмяПоля) Тогда
		ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
		СпособПоиска = 1;
	Иначе
		СпособПоиска = 2;
		ЗначениеПоиска = Представление;
	КонецЕсли;
	
	МассивЭлементов = Новый Массив;
	
	НайтиРекурсивно(ОбластьПоиска.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
	
	Для Каждого Элемент Из МассивЭлементов Цикл
		Если ИмяПоля <> Неопределено Тогда
			Элемент.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПоля);
		КонецЕсли;
		Если Представление <> Неопределено Тогда
			Элемент.Представление = Представление;
		КонецЕсли;
		Если Использование <> Неопределено Тогда
			Элемент.Использование = Использование;
		КонецЕсли;
		Если ВидСравнения <> Неопределено Тогда
			Элемент.ВидСравнения = ВидСравнения;
		КонецЕсли;
		Если ПравоеЗначение <> Неопределено Тогда
			Элемент.ПравоеЗначение = ПравоеЗначение;
		КонецЕсли;
		Если РежимОтображения <> Неопределено Тогда
			Элемент.РежимОтображения = РежимОтображения;
		КонецЕсли;
	КонецЦикла;
	
	Возврат МассивЭлементов.Количество();
	
КонецФункции

// Поиск элементов и групп отбора динамического списка
// Параметры:
//  ОбластьУдаления - контейнер с элементами и группами отбора, например
//                  Список.Отбор или группа в отборе
//  ИмяПоля - имя поля компоновки (не используется для групп)
//  Представление - представление поля компоновки
//  Примечание: поиск может осуществляться или по ЛевомуЗначению, или по Представлению
//
Процедура УдалитьЭлементыГруппыОтбора(знач ОбластьУдаления,
										знач ИмяПоля = Неопределено,
										знач Представление = Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(ИмяПоля) Тогда
		ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
		СпособПоиска = 1;
	Иначе
		СпособПоиска = 2;
		ЗначениеПоиска = Представление;
	КонецЕсли;
	
	МассивЭлементов = Новый Массив;
	
	НайтиРекурсивно(ОбластьУдаления.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
	
	Для Каждого Элемент Из МассивЭлементов Цикл
		Если Элемент.Родитель = Неопределено Тогда
			ОбластьУдаления.Элементы.Удалить(Элемент);
		Иначе
			Элемент.Родитель.Элементы.Удалить(Элемент);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Используется для создания элемента отбора или, если таковой не найден,
// установления существующим элементам свойств
// Параметры
//  ОбластьПоискаДобавления - контейнер с элементами и группами отбора, например
//                  Список.Отбор или группа в отборе
//  ИмяПоля - строка - имя для поля компоновки данных (заполняется всегда)
// Устанавливаемые поля:
//  ВидСравнения - ВидСравненияКомпоновкиДанных - вид сравнения
//  ПравоеЗначение - произвольный
//  Представление - представление элемента компоновки данных
//  Использование - булево - использование элемента
//  РежимОтображения - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения
//
Процедура УстановитьЭлементОтбора(ОбластьПоискаДобавления,
								знач ИмяПоля,
								знач ПравоеЗначение = Неопределено,
								знач ВидСравнения = Неопределено,
								знач Представление = Неопределено,
								знач Использование = Неопределено,
								знач РежимОтображения = Неопределено) Экспорт
	
	ЧислоИзмененных = ИзменитьЭлементыОтбора(ОбластьПоискаДобавления, ИмяПоля, Представление,
							ПравоеЗначение, ВидСравнения, Использование, РежимОтображения);
	
	Если ЧислоИзмененных = 0 Тогда
		Если ВидСравнения = Неопределено Тогда
			ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
		КонецЕсли;
		ДобавитьЭлементКомпоновки(ОбластьПоискаДобавления, ИмяПоля, ВидСравнения,
								ПравоеЗначение, Представление, Использование, РежимОтображения);
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает значение Значение параметра ИмяПараметра динамического списка Список 
// или отключает его использование в зависимости от признака Использование.
//
Процедура УстановитьПараметрДинамическогоСписка(Список, ИмяПараметра, Значение, Использование = Истина) Экспорт
	
	Если Использование Тогда
		Список.Параметры.УстановитьЗначениеПараметра(ИмяПараметра, Значение);
	Иначе
		ЗначениеПараметра = Список.Параметры.НайтиЗначениеПараметра(Новый ПараметрКомпоновкиДанных(ИмяПараметра));
		Если ЗначениеПараметра <> Неопределено Тогда
			ЗначениеПараметра.Значение = Значение;
			ЗначениеПараметра.Использование = Ложь;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры 

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с управляемыми формами
//

// Получает значение реквизита формы
// Параметры:
//		Форма
//		ПутьРеквизита - строка, путь к данным, например: "Объект.МесяцНачисления"
Функция ПолучитьРеквизитФормыПоПути(Форма, ПутьРеквизита) Экспорт
	
	МассивИмен = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПутьРеквизита, ".");
	
	Объект        = Форма;
	ПоследнееПоле = МассивИмен[МассивИмен.Количество()-1];
	
	Для Сч = 0 по МассивИмен.Количество()-2 Цикл
		Объект = Объект[МассивИмен[Сч]]
	КонецЦикла;
	
	Возврат Объект[ПоследнееПоле];
	
КонецФункции

// Устанавливает значение реквизиту формы
// Параметры:
//		Форма
//		ПутьРеквизита - строка, путь к данным, например: "Объект.МесяцНачисления"
//		Значение
Процедура УстановитьРеквизитФормыПоПути(Форма, ПутьРеквизита, Значение, ТолькоЕслиНеЗаполнен = Ложь) Экспорт
	
	МассивИмен = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПутьРеквизита, ".");
	
	Объект        = Форма;
	ПоследнееПоле = МассивИмен[МассивИмен.Количество()-1];
	
	Для Сч = 0 по МассивИмен.Количество()-2 Цикл
		Объект = Объект[МассивИмен[Сч]]
	КонецЦикла;
	Если НЕ ТолькоЕслиНеЗаполнен ИЛИ НЕ ЗначениеЗаполнено(Объект[ПоследнееПоле]) Тогда
		Объект[ПоследнееПоле] = Значение;
	КонецЕсли;
	
КонецПроцедуры

// Выполняет поиск элемента отбора в коллекции по заданному представлению
//
// Параметры:
//  КоллекцияЭлементов - контейнер с элементами и группами отбора, например
//                      Список.Отбор.Элементы или группа в отборе
//  Представление строка - представление группы
// 
Функция НайтиЭлементОтбораПоПредставлению(КоллекцияЭлементов, Представление) Экспорт
	
	ВозвращаемоеЗначение = Неопределено;
	
	Для каждого ЭлементОтбора Из КоллекцияЭлементов Цикл
		Если ЭлементОтбора.Представление = Представление Тогда
			ВозвращаемоеЗначение = ЭлементОтбора;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ВозвращаемоеЗначение
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Прочие функции
//

// Возвращает шаблон структуры параметров для установки внешнего соединения.
// Параметрам необходимо задать требуемые значения и передать
// в метод ОбщегоНазначения.УстановитьВнешнееСоединение()
//
Функция СтруктураПараметровДляУстановкиВнешнегоСоединения() Экспорт
	
	СтруктураПараметров = Новый Структура;
	СтруктураПараметров.Вставить("ВариантРаботыИнформационнойБазы", 0);
	СтруктураПараметров.Вставить("КаталогИнформационнойБазы", "");
	СтруктураПараметров.Вставить("ИмяСервера1СПредприятия", "");
	СтруктураПараметров.Вставить("ИмяИнформационнойБазыНаСервере1СПредприятия", "");
	СтруктураПараметров.Вставить("АутентификацияОперационнойСистемы", Ложь);
	СтруктураПараметров.Вставить("ИмяПользователя", "");
	СтруктураПараметров.Вставить("ПарольПользователя", "");
	
	Возврат СтруктураПараметров;
КонецФункции

// Извлекает из строки соединения с информационной базой параметры подключения
// и передает параметры в структуру для установки внешнего соединения.
//
Функция ПолучитьПараметрыПодключенияИзСтрокиСоединенияИнформационнойБазы(Знач СтрокаСоединения) Экспорт
	
	Результат = СтруктураПараметровДляУстановкиВнешнегоСоединения();
	
	Параметры = СтроковыеФункцииКлиентСервер.ПолучитьПараметрыИзСтроки(СтрокаСоединения);
	
	Параметры.Свойство("File", Результат.КаталогИнформационнойБазы);
	Параметры.Свойство("Srvr", Результат.ИмяСервера1СПредприятия);
	Параметры.Свойство("Ref",  Результат.ИмяИнформационнойБазыНаСервере1СПредприятия);
	
	Результат.ВариантРаботыИнформационнойБазы = ?(Параметры.Свойство("File"), 0, 1);
	
	Возврат Результат;
КонецФункции

// Для файлового режима работы возвращает полное имя каталога, в котором расположена информационная база.
// Если режим работы клиент-серверный, то возвращается пустая строка.
//
// Параметры:
//  Нет.
// 
//  Возвращаемое значение:
// Тип: Строка. Полное имя каталога, в котором расположена файловая информационная база.
//
Функция КаталогФайловойИнформационнойБазы() Экспорт
	
	ПараметрыСоединения = СтроковыеФункцииКлиентСервер.ПолучитьПараметрыИзСтроки(СтрокаСоединенияИнформационнойБазы());
	
	Если ПараметрыСоединения.Свойство("File") Тогда
		Возврат ПараметрыСоединения.File;
	КонецЕсли;
	
	Возврат "";
КонецФункции

// Получает идентификатор (метод ПолучитьИдентификатор()) строки дерева значений для заданного значения поля строки дерева.
// Используется для позиционирования курсора в иерархических списках.
// 
Процедура ПолучитьИдентификаторСтрокиДереваПоЗначениюПоля(ИмяПоля, ИдентификаторСтроки, КоллекцияЭлементовДерева, КлючСтроки, ПрекратитьПоиск) Экспорт
	
	Для Каждого СтрокаДерева ИЗ КоллекцияЭлементовДерева Цикл
		
		Если ПрекратитьПоиск Тогда
			Возврат;
		КонецЕсли;
		
		Если СтрокаДерева[ИмяПоля] = КлючСтроки Тогда
			
			ИдентификаторСтроки = СтрокаДерева.ПолучитьИдентификатор();
			
			ПрекратитьПоиск = Истина;
			
			Возврат;
			
		КонецЕсли;
		
		КоллекцияЭлементов = СтрокаДерева.ПолучитьЭлементы();
		
		Если КоллекцияЭлементов.Количество() > 0 Тогда
			
			ПолучитьИдентификаторСтрокиДереваПоЗначениюПоля(ИмяПоля, ИдентификаторСтроки, КоллекцияЭлементов, КлючСтроки, ПрекратитьПоиск);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Заменяет недопустимые символы в XML-строке на заданные символы
//
// Параметры:
//   Текст – Строка – строка, в которой требуется выполнить замену недопустимых символов.
//   СимволЗамены – Строка – строка, на которую требуется выполнить замену недопустимого символа в XML-строке
// 
//  Возвращаемое значение:
//    Строка - cтрока, полученная заменой недопустимых символов в XML-строке.
//
Функция ЗаменитьНедопустимыеСимволыXML(Знач Текст, СимволЗамены = " ") Экспорт
	
#Если НЕ ВебКлиент Тогда
	ПозицияНачала = 1;
	Пока Истина Цикл
		Позиция = НайтиНедопустимыеСимволыXML(Текст, ПозицияНачала);
		Если Позиция = 0 Тогда
			Прервать;
		КонецЕсли;
		// Если возращается позиция, больше чем должна быть, то корректируем ее.
		Если Позиция > 1 Тогда
			НедопустимыйСимвол = Сред(Текст, Позиция - 1, 1);
			Если НайтиНедопустимыеСимволыXML(НедопустимыйСимвол) > 0 Тогда
				Текст = СтрЗаменить(Текст, НедопустимыйСимвол, СимволЗамены);
			КонецЕсли;
		КонецЕсли;
		НедопустимыйСимвол = Сред(Текст, Позиция, 1);
		Если НайтиНедопустимыеСимволыXML(НедопустимыйСимвол) > 0 Тогда
			Текст = СтрЗаменить(Текст, НедопустимыйСимвол, СимволЗамены);
		КонецЕсли;
		ПозицияНачала = Позиция + 1;
	КонецЦикла;
#КонецЕсли

	Возврат Текст;
КонецФункции

// Удаляет недопустимые символы в XML-строке.
//
// Параметры:
//  Текст – Строка – строка, в которой требуется удалить недопустимые символы.
// 
//  Возвращаемое значение:
//  Тип: Строка. Строка, полученная при удалении недопустимых символов в XML-строке.
//
Функция УдалитьНедопустимыеСимволыXML(Знач Текст) Экспорт
	
	Возврат ЗаменитьНедопустимыеСимволыXML(Текст, "");
	
КонецФункции

// Сравнивает расписания между собой.
//
// Параметры
//	Расписание1, Расписание2 - РасписаниеРегламентногоЗадания
//
// Возвращаемое значение
//  Булево - истина, если расписания идентичны, иначе ложь.
Функция РасписанияОдинаковые(Знач Расписание1, Знач Расписание2) Экспорт
	Расписание1 = РасписаниеВСтруктуру(Расписание1);
	Расписание2 = РасписаниеВСтруктуру(Расписание2);
	
	Для Каждого РеквизитРасписания Из Расписание1 Цикл
		Если ТипЗнч(РеквизитРасписания.Значение) <> Тип("Массив") Тогда
			Если РеквизитРасписания.Значение <> Расписание2[РеквизитРасписания.Ключ] Тогда
				Возврат Ложь;
			КонецЕсли;
		Иначе
			Если РеквизитРасписания.Значение.Количество() <> Расписание2[РеквизитРасписания.Ключ].Количество() Тогда
				Возврат Ложь;
			КонецЕсли;
			
			Для НомерЭлемента = 0 По РеквизитРасписания.Значение.Количество()-1 Цикл
				Если РеквизитРасписания.Ключ = "ДетальныеРасписанияДня" Тогда
					Если Не РасписанияОдинаковые(РеквизитРасписания.Значение[НомерЭлемента],Расписание2[РеквизитРасписания.Ключ][НомерЭлемента]) Тогда
						Возврат Ложь;
					КонецЕсли;
				Иначе
					Если РеквизитРасписания.Значение[НомерЭлемента] <> Расписание2[РеквизитРасписания.Ключ][НомерЭлемента] Тогда
						Возврат Ложь;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
КонецФункции

// Устанавливает свойство ИмяСвойства элемента формы с именем ИмяЭлемента в значение Значение.
// Применяется в тех случаях, когда элемент формы может не быть на форме из-за отсутствия прав у пользователя
// на объект, реквизит объекта или команду.
//
// Параметры:
//  ЭлементыФормы - свойство ЭлементыФормы управляемой формы.
//  ИмяЭлемента   - Строка       - имя элемента формы
//  ИмяСвойства   - Строка       - имя устанавливаемого свойства элемента формы
//  Значение      - Произвольный - новое значение элемента
// 
Процедура УстановитьСвойствоЭлементаФормы(ЭлементыФормы, ИмяЭлемента, ИмяСвойства, Значение) Экспорт

	ЭлементФормы = ЭлементыФормы.Найти(ИмяЭлемента);
	Если ЭлементФормы <> Неопределено  Тогда
		ЭлементФормы[ИмяСвойства] = Значение;
	КонецЕсли;

КонецПроцедуры 

// Возвращает значение свойства ИмяСвойства элемента формы с именем ИмяЭлемента.
// Применяется в тех случаях, когда элемент формы может не быть на форме из-за отсутствия прав у пользователя
// на объект, реквизит объекта или команду.
//
// Параметры:
//  ЭлементыФормы - свойство ЭлементыФормы управляемой формы.
//  ИмяЭлемента   - Строка       - имя элемента формы
//  ИмяСвойства   - Строка       - имя свойства элемента формы
// 
// Возвращаемое значение:
//   Произвольный - значение свойства ИмяСвойства элемента формы ИмяЭлемента.
// 
Функция ЗначениеСвойстваЭлементаФормы(ЭлементыФормы, ИмяЭлемента, ИмяСвойства) Экспорт

	ЭлементФормы = ЭлементыФормы.Найти(ИмяЭлемента);
	Возврат ?(ЭлементФормы <> Неопределено, ЭлементФормы[ИмяСвойства], Неопределено);

КонецФункции 

////////////////////////////////////////////////////////////////////////////////
// СЛУЖЕБНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

// Функция выполняет поиск элемента в коллекции: списке значений или массиве
//
Функция НайтиВСписке(Список, Элемент)
	
	Перем ЭлементВСписке;
	
	Если ТипЗнч(Список) = Тип("СписокЗначений") Тогда
		Если ТипЗнч(Элемент) = Тип("ЭлементСпискаЗначений") Тогда
			ЭлементВСписке = Список.НайтиПоЗначению(Элемент.Значение);
		Иначе
			ЭлементВСписке = Список.НайтиПоЗначению(Элемент);
		КонецЕсли;
	КонецЕсли;
	
	Если ТипЗнч(Список) = Тип("Массив") Тогда
		ЭлементВСписке = Список.Найти(Элемент);
	КонецЕсли;
	
	Возврат ЭлементВСписке;
	
КонецФункции // ЭлементПрисутствуетВСписке

// Проверяет, что почтовый адрес не содержит символов обрамления
// если символы обрамления вставлены правильно убирает их
// Параметры:
//  ПолноеИмяАдресата - строка - имя получателя
//  ПочтовыйАдрес     - строка - email адрес
// Возвращаемое значение:
//  Структура:
//   Ключ статус - булево - успех или неуспех операции
//   СообщениеОбОшибке - в случае неуспеха операции содержит сообщение об ошибке
//   Значение - структура - в случае успеха операции содержит записанную структуру почтового
//                          адреса: ключи - Адрес, Представление (строки)
//
Функция ПроверитьИПодготовитьПочтовыйАдрес(знач ПолноеИмяАдресата, знач ПочтовыйАдрес)
	
	НедопустимыйСимволВИмениАдресата = НСтр("ru = 'Недопустимый символ в имени адресата.'");
	НедопустимыйСимволВПочтовомАдресе = НСтр("ru = 'Недопустимый символ в почтовом адресе.'");
	СимволыОбрамления = "<>[]";
	
	ПочтовыйАдрес     = СокрЛП(ПочтовыйАдрес);
	ПолноеИмяАдресата = СокрЛП(ПолноеИмяАдресата);
	
	Если Лев(ПолноеИмяАдресата, 1) = "<" Тогда
		Если Прав(ПолноеИмяАдресата, 1) = ">" Тогда
			ПолноеИмяАдресата = Сред(ПолноеИмяАдресата, 2, СтрДлина(ПолноеИмяАдресата)-2);
		Иначе
			ВызватьИсключение НедопустимыйСимволВИмениАдресата;
		КонецЕсли;
	ИначеЕсли Лев(ПолноеИмяАдресата, 1) = "[" Тогда
		Если Прав(ПолноеИмяАдресата, 1) = "]" Тогда
			ПолноеИмяАдресата = Сред(ПолноеИмяАдресата, 2, СтрДлина(ПолноеИмяАдресата)-2);
		Иначе
			ВызватьИсключение НедопустимыйСимволВИмениАдресата;
		КонецЕсли;
	КонецЕсли;
	
	Если Лев(ПочтовыйАдрес, 1) = "<" Тогда
		Если Прав(ПочтовыйАдрес, 1) = ">" Тогда
			ПочтовыйАдрес = Сред(ПочтовыйАдрес, 2, СтрДлина(ПочтовыйАдрес)-2);
		Иначе
			ВызватьИсключение НедопустимыйСимволВПочтовомАдресе;
		КонецЕсли;
	ИначеЕсли Лев(ПочтовыйАдрес, 1) = "[" Тогда
		Если Прав(ПочтовыйАдрес, 1) = "]" Тогда
			ПочтовыйАдрес = Сред(ПочтовыйАдрес, 2, СтрДлина(ПочтовыйАдрес)-2);
		Иначе
			ВызватьИсключение НедопустимыйСимволВПочтовомАдресе;
		КонецЕсли;
	КонецЕсли;
	
	Для Индекс = 1 По СтрДлина(СимволыОбрамления) Цикл
		Если Найти(ПолноеИмяАдресата, Сред(СимволыОбрамления, Индекс, 1)) <> 0
		 ИЛИ Найти(ПочтовыйАдрес,     Сред(СимволыОбрамления, Индекс, 1)) <> 0 Тогда
			ВызватьИсключение НедопустимыйСимволВПочтовомАдресе;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Новый Структура("Адрес, Представление", ПочтовыйАдрес,ПолноеИмяАдресата);
	
КонецФункции

// Сдвигает маркер позиции пока встречается символ Символ
// возвращает номер позиции в строке, на которое установился маркер
//
Функция ПропуститьПробелы(знач Строка,
                          знач ТекущийИндекс,
                          знач ПропускаемыйСимвол)
	
	Результат = ТекущийИндекс;
	
	// убираем лишние пробелы если они есть
	Пока ТекущийИндекс < СтрДлина(Строка) Цикл
		Если Сред(Строка, ТекущийИндекс, 1) <> ПропускаемыйСимвол Тогда
			Возврат ТекущийИндекс;
		КонецЕсли;
		ТекущийИндекс = ТекущийИндекс + 1;
	КонецЦикла;
	
	Возврат ТекущийИндекс;
	
КонецФункции

Процедура НайтиРекурсивно(КоллекцияЭлементов, МассивЭлементов, СпособПоиска, ЗначениеПоиска)
	
	Для каждого ЭлементОтбора Из КоллекцияЭлементов Цикл
		
		Если ТипЗнч(ЭлементОтбора) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
			
			Если СпособПоиска = 1 Тогда
				Если ЭлементОтбора.ЛевоеЗначение = ЗначениеПоиска Тогда
					МассивЭлементов.Добавить(ЭлементОтбора);
				КонецЕсли;
			ИначеЕсли СпособПоиска = 2 Тогда
				Если ЭлементОтбора.Представление = ЗначениеПоиска Тогда
					МассивЭлементов.Добавить(ЭлементОтбора);
				КонецЕсли;
			КонецЕсли;
		Иначе
			
			НайтиРекурсивно(ЭлементОтбора.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
			
			Если СпособПоиска = 2 И ЭлементОтбора.Представление = ЗначениеПоиска Тогда
				МассивЭлементов.Добавить(ЭлементОтбора);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Функция ЗаменитьСимволыВСтрокеНаПробелы(Строка, ЗаменяемыеСимволы)
	Результат = Строка;
	Для Позиция = 1 по СтрДлина(Символы) Цикл
		Результат = СтрЗаменить(Результат, Сред(ЗаменяемыеСимволы, Позиция, 1), " ");
	КонецЦикла;
	Возврат Результат;
КонецФункции

Функция ЕстьСимволыВНачалеВКонце(Строка, ПроверяемыеСимволы)
	Для Позиция = 1 По СтрДлина(ПроверяемыеСимволы) Цикл
		Символ = Сред(ПроверяемыеСимволы, Позиция, 1);
		СимволНайден = (Лев(Строка,1) = Символ) или (Прав(Строка,1) = Символ);
		Если СимволНайден Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
КонецФункции

Функция СтрокаСодержитТолькоДопустимыеСимволы(Строка, ДопустимыеСимволы)
	МассивСимволов = Новый Массив;
	Для Позиция = 1 по СтрДлина(ДопустимыеСимволы) Цикл
		МассивСимволов.Добавить(Сред(ДопустимыеСимволы,Позиция,1));
	КонецЦикла;
	
	Для Позиция = 1 по СтрДлина(Строка) Цикл
		Если МассивСимволов.Найти(Сред(Строка, Позиция, 1)) = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
КонецФункции

// Дополняет структуру значениями из другой структуры.
//
// Параметры:
//   Приемник - Структура - коллекция, в которую будут добавляться новые значения.
//   Источник - Структура - коллекция, из которой будут считываться пары Ключ и Значение для заполнения.
//   Заменять - Булево, Неопределено - Что делать в местах пересечения ключей источника и приемника:
//                                       Истина - Заменять значения приемника (самый быстрый способ),
//                                       Ложь   - Не заменять значения приемника (пропускать),
//                                       Неопределено - Значение по умолчанию. Бросать исключение.
//
Процедура ДополнитьСтруктуру(Приемник, Источник, Заменять = Неопределено) Экспорт
	
	Для Каждого Элемент Из Источник Цикл
		Если Заменять <> Истина И Приемник.Свойство(Элемент.Ключ) Тогда
			Если Заменять = Ложь Тогда
				Продолжить;
			Иначе
				ВызватьИсключение СтрШаблон(НСтр("ru='Пересечение ключей источника и приемника: ""%1"".';uk='Перетинання ключів джерела й приймача: ""%1"".'"), Элемент.Ключ);
			КонецЕсли
		КонецЕсли;
		Приемник.Вставить(Элемент.Ключ, Элемент.Значение);
	КонецЦикла;
	
КонецПроцедуры

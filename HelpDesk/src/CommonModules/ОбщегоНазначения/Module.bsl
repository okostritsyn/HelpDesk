// Подсистема "Базовая функциональность".
// Серверные процедуры и функции общего назначения:
// - для работы с данными в базе;
// - для работы с прикладными типами и коллекциями значений;
// - математические процедуры и функции;
// - для работы с внешним соединением;
// - для работы с формами;
// - для работы с типами, объектами метаданных и их строковыми представлениями;
// - функции определения типов объектов метаданных;
// - сохранение, чтение и удаление настроек из хранилищ;
// - для работы с табличными документами;
// - для работы с журналом регистрации;
// - для работы в режиме разделения данных;
// - версионирование программных интерфейсов;
// - вспомогательные процедуры и функции.
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// ПРОГРАММНЫЙ ИНТЕРФЕЙС

////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции для работы с данными в базе

// Возвращает структуру, содержащую значения реквизитов прочитанные из информационной базы
// по ссылке на объект.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//  ИменаРеквизитов - Строка или Структура - если Строка, то имена реквизитов, 
//               перечисленные через запятую, в формате требований к свойствам структуры.
//               Например, "Код, Наименование, Родитель".
//               Если Структура, то в качестве ключа передается псевдоним поля для
//               возвращаемой структуры с результатом, а в качестве значения (опционально) 
//               - фактическое имя поля в таблице. 
//               Если значение не определено, то имя поля берется из ключа.
// 
// Возвращаемое значение:
//  Структура    - содержит список свойств, как список имен в строке
//                 ИменаРеквизитов, со значениям реквизитов, прочитанных
//                 из информационной базы.
// 
Функция ПолучитьЗначенияРеквизитов(Ссылка, ИменаРеквизитов) Экспорт

	Если ТипЗнч(ИменаРеквизитов) = Тип("Структура") Тогда
		СтруктураРеквизитов = ИменаРеквизитов;
	ИначеЕсли ТипЗнч(ИменаРеквизитов) = Тип("Строка") Тогда
		СтруктураРеквизитов = Новый Структура(ИменаРеквизитов);;
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверный тип второго параметра ИменаИлиСтруктураРеквизитов: %1'"), 
			Строка(ТипЗнч(ИменаРеквизитов)));
	КонецЕсли;

	ТекстПолей = "";
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		ИмяПоля   = ?(ЗначениеЗаполнено(КлючИЗначение.Значение), СокрЛП(КлючИЗначение.Значение), СокрЛП(КлючИЗначение.Ключ));
		Псевдоним = СокрЛП(КлючИЗначение.Ключ);
		ТекстПолей  = ТекстПолей + ?(ПустаяСтрока(ТекстПолей), "", ",") + "
			|	" + ИмяПоля + " КАК " + Псевдоним;
	КонецЦикла;

	Запрос = Новый Запрос(
		"ВЫБРАТЬ
		|" + ТекстПолей + "
		|ИЗ
		|	" + Ссылка.Метаданные().ПолноеИмя() + " КАК ПсевдонимЗаданнойТаблицы
		|ГДЕ
		|	ПсевдонимЗаданнойТаблицы.Ссылка = &Ссылка
		|");
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();

	Результат = Новый Структура;
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		Результат.Вставить(КлючИЗначение.Ключ);
	КонецЦикла;
	ЗаполнитьЗначенияСвойств(Результат, Выборка);

	Возврат Результат;
КонецФункции

// Возвращает значение реквизита, прочитанного из информационной базы по ссылке на объект.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Произвольный    - зависит от типа значения прочитанного реквизита.
// 
Функция ПолучитьЗначениеРеквизита(Ссылка, ИмяРеквизита) Экспорт
	
	Результат = ПолучитьЗначенияРеквизитов(Ссылка, ИмяРеквизита);
	Возврат Результат[ИмяРеквизита];
	
КонецФункции 

// Возвращает структуру, содержащую значения реквизитов, прочитанные из информационной базы
// для нескольких объектов.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  МассивСсылок - массив ссылок на объекты одного типа
//				ВАЖНО! значения массива должны быть ссылками на 
//				объекты одного типа!
//  ИменаРеквизитов - Строка, имена реквизитов перечисленные через запятую,
//				в формате требований к свойствам структуры.
//				Например, "Код, Наименование, Родитель".
// 
// Возвращаемое значение:
//  Соответствие, где ключ - ссылка на объект, а Значение - структура, которая 
//				содержит список свойств, как список имен в строке
//				ИменаРеквизитов, со значениям реквизитов, прочитанными
//				из информационной базы.
// 
Функция ЗначенияРеквизитовОбъектов(МассивСсылок, ИменаРеквизитов) Экспорт
	
	ЗначенияРеквизитов = Новый Соответствие;
	Если МассивСсылок.Количество() = 0 Тогда
		Возврат ЗначенияРеквизитов;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ
		|	Ссылка КАК Ссылка, " + ИменаРеквизитов + "
		|ИЗ
		|	" + МассивСсылок[0].Метаданные().ПолноеИмя() + " КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка В (&МассивСсылок)";
	Запрос.УстановитьПараметр("МассивСсылок", МассивСсылок);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Результат = Новый Структура(ИменаРеквизитов);
		ЗаполнитьЗначенияСвойств(Результат, Выборка);
		ЗначенияРеквизитов[Выборка.Ссылка] = Результат;
	КонецЦикла;
	
	Возврат ЗначенияРеквизитов;
	
КонецФункции

// Возвращает значения реквизита, прочитанного из информационной базы для нескольких объектов.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  МассивСсылок - массив ссылок на объекты одного типа
//				ВАЖНО! значения массива должны быть ссылками на 
//				объекты одного типа!
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Соответствие, где ключ - ссылка на объект, Значение - значение прочитанного реквизита
// 
Функция ЗначениеРеквизитаОбъектов(МассивСсылок, ИмяРеквизита) Экспорт
	
	ЗначенияРеквизитов = ЗначенияРеквизитовОбъектов(МассивСсылок, ИмяРеквизита);
	Для Каждого Элемент Из ЗначенияРеквизитов Цикл
		ЗначенияРеквизитов[Элемент.Ключ] = Элемент.Значение[ИмяРеквизита];
	КонецЦикла;
		
	Возврат ЗначенияРеквизитов;
	
КонецФункции

// Проверяет проведенность документов
//
// Параметры:
//  Документы - Массив - документы, проведенность которых необходимо проверить
//
// Возвращаемое значение:
//  Массив - непроведенные документы из массива Документы
//
Функция ПроверитьПроведенностьДокументов(знач Документы) Экспорт
	
	Результат = Новый Массив;
	
	ШаблонЗапроса = 	
		"ВЫБРАТЬ
		|	Документ.Ссылка КАК Ссылка
		|ИЗ
		|	&ИмяДокумента КАК Документ
		|ГДЕ
		|	Документ.Ссылка В(&МассивДокументов)
		|	И (НЕ Документ.Проведен)";
	
	ТекстОбъединитьВсе =
		"
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|";
		
	ИменаДокументов = Новый Массив;
	Для Каждого Документ Из Документы Цикл
		ИмяДокумента = Документ.Метаданные().ПолноеИмя();
		Если ИменаДокументов.Найти(ИмяДокумента) = Неопределено
		   и Метаданные.Документы.Содержит(Метаданные.НайтиПоПолномуИмени(ИмяДокумента)) Тогда	
			ИменаДокументов.Добавить(ИмяДокумента);
		КонецЕсли;
	КонецЦикла;
	
	ТекстЗапроса = "";
	Для Каждого ИмяДокумента Из ИменаДокументов Цикл
		Если Не ПустаяСтрока(ТекстЗапроса) Тогда
			ТекстЗапроса = ТекстЗапроса + ТекстОбъединитьВсе;
		КонецЕсли;
		ТекстПодзапроса = СтрЗаменить(ШаблонЗапроса, "&ИмяДокумента", ИмяДокумента);
		ТекстЗапроса = ТекстЗапроса + ТекстПодзапроса;
	КонецЦикла;
		
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("МассивДокументов", Документы);
	
	Если Не ПустаяСтрока(ТекстЗапроса) Тогда
		Результат = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Выполняет попытку проведения документов.
//
// Параметры:
//	Документы                - Массив - документы, которые необходимо провести.
//
// Возвращаемое значение:
//	Массив - массив структур с полями:
//									Ссылка         - документ, который не удалось провести;
//									ОписаниеОшибки - текст описания ошибки при проведении.
//
Функция ПровестиДокументы(Документы) Экспорт
	
	НепроведенныеДокументы = Новый Массив;
	
	Для Каждого ДокументСсылка Из Документы Цикл
		
		ВыполненоУспешно = Ложь;
		ДокументОбъект = ДокументСсылка.ПолучитьОбъект();
		Если ДокументОбъект.ПроверитьЗаполнение() Тогда
			Попытка
				ДокументОбъект.Записать(РежимЗаписиДокумента.Проведение);
				ВыполненоУспешно = Истина;
			Исключение
				ПредставлениеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
				ТекстСообщенияОбОшибке = НСтр("ru = 'Ошибка при попытке проведения документа: %1'");
				ТекстСообщенияОбОшибке = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстСообщенияОбОшибке, ПредставлениеОшибки);
				ЗаписьЖурналаРегистрации(НСтр("ru = 'Проведение документов при печати'"),
					УровеньЖурналаРегистрации.Информация, ДокументОбъект.Метаданные(), ДокументСсылка, 
					ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			КонецПопытки;
		Иначе
			ПредставлениеОшибки = НСтр("ru = 'Поля документа не заполнены.'");
		КонецЕсли;
		
		Если Не ВыполненоУспешно Тогда
			НепроведенныеДокументы.Добавить(Новый Структура("Ссылка,ОписаниеОшибки", ДокументСсылка, ПредставлениеОшибки));
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат НепроведенныеДокументы;
	
КонецФункции 

// Проверяет наличие ссылок на объект в базе данных.
//
// Параметры:
//  Ссылка       - ЛюбаяСсылка
//               - Массив значений типа ЛюбаяСсылка
//
//  ИскатьСредиСлужебныхОбъектов - Булево - начальное значение Ложь,
//                 когда установлено Истина, тогда не будет учитываться
//                 исключения поиска ссылок, заданные при разработке конфигурации.
//
// Возвращаемое значение:
//  Булево.
//
Функция ОбъектИспользуютсяВБазеДанных(Знач СсылкаИлиМассивСсылок, Знач ИскатьСредиСлужебныхОбъектов = Ложь) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если ТипЗнч(СсылкаИлиМассивСсылок) = Тип("Массив") Тогда
		МассивСсылок = СсылкаИлиМассивСсылок;
	Иначе
		МассивСсылок = Новый Массив;
		МассивСсылок.Добавить(СсылкаИлиМассивСсылок);
	КонецЕсли;
	
	ТаблицаСсылок = НайтиПоСсылкам(МассивСсылок);
	
	Если НЕ ИскатьСредиСлужебныхОбъектов Тогда
		
		СлужебныеОбъекты = ПолучитьОбщийСписокИсключенийПоискаСсылок();
		Исключения = Новый Массив;
		
		Для каждого ОписаниеСсылки Из ТаблицаСсылок Цикл
			Если СлужебныеОбъекты.Найти(ОписаниеСсылки.Метаданные.ПолноеИмя()) <> Неопределено Тогда
				Исключения.Добавить(ОписаниеСсылки);
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого СтрокаИсключение Из Исключения Цикл
			ТаблицаСсылок.Удалить(СтрокаИсключение);
		КонецЦикла;
	КонецЕсли;
	
	
	Возврат ТаблицаСсылок.Количество() > 0;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции для работы с прикладными типами и коллекциями значений

// Получает имя значения перечисления как объекта метаданных
//
// Параметры:
//  Значение - значение перечисления для которого необходимо получить имя перечисления
//
// Возвращаемое значение:
//  Строка - имя значения перечисления как объекта метаданных
//
Функция ИмяЗначенияПеречисления(Значение) Экспорт
	
	ОбъектМетаданных = Значение.Метаданные();
	
	ИндексЗначения = Перечисления[ОбъектМетаданных.Имя].Индекс(Значение);
	
	Возврат ОбъектМетаданных.ЗначенияПеречисления[ИндексЗначения].Имя;
	
КонецФункции 

// Заполняет массив-приемник уникальными значениями из массива-источника.
// Если элемент в массиве-приемнике уже существует, то добавления нового элемента не происходит.
//
// Параметры:
//  МассивПриемник – Массив – массив, который заполняется уникальными значениями
//  МассивИсточник – Массив – массив, из которого подбираются элементы в массив-приемник.
// 
Процедура ЗаполнитьМассивУникальнымиЗначениями(МассивПриемник, МассивИсточник) Экспорт
	
	УникальныеЗначения = Новый Соответствие;
	
	Для каждого Значение Из МассивПриемник Цикл
		УникальныеЗначения.Вставить(Значение, Истина);
	КонецЦикла;
	
	Для каждого Значение Из МассивИсточник Цикл
		Если УникальныеЗначения[Значение] = Неопределено Тогда
			МассивПриемник.Добавить(Значение);
			УникальныеЗначения.Вставить(Значение, Истина);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Процедура удаляет из массива МассивРеквизитов элементы, соответствующие именам 
// реквизитов объекта из массива МассивНепроверяемыхРеквизитов.
// Для использования в обработчиках события ОбработкаПроверкиЗаполнения.
//
// Параметры:
//	МассивРеквизитов              - Массив - массив строк с именами реквизитов объекта.
//	МассивНепроверяемыхРеквизитов - Массив строк с именами реквизитов объекта, не требующих проверки.
//
Процедура УдалитьНепроверяемыеРеквизитыИзМассива(МассивРеквизитов, МассивНепроверяемыхРеквизитов) Экспорт
	
	Для Каждого ЭлементМассива Из МассивНепроверяемыхРеквизитов Цикл
	
		ПорядковыйНомер = МассивРеквизитов.Найти(ЭлементМассива);
		Если ПорядковыйНомер <> Неопределено Тогда
			МассивРеквизитов.Удалить(ПорядковыйНомер);
		КонецЕсли;
	
	КонецЦикла;
	
КонецПроцедуры

//	Преобразует таблицу значений в массив.
//	Может использоваться для передачи на клиента данных, полученных
//	на сервере в виде таблицы значений в том случае, если таблица
//	значений содержит только такие значения, которые могут
//  быть переданы на клиента
//
//	Полученный массив содержит структуры, каждая из которых повторяет
//	структуру колонок таблицы значений.
//
//	Не рекомендуется использовать для преобразования таблиц значений
//	с большим количеством строк.
//
//	Параметры: ТаблицаЗначений
//	Возвращаемое значение: Массив
//
Функция ТаблицаЗначенийВМассив(ТаблицаЗначений) Экспорт
	
	Массив = Новый Массив();
	СтруктураСтрокой = "";
	НужнаЗапятая = Ложь;
	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		Если НужнаЗапятая Тогда
			СтруктураСтрокой = СтруктураСтрокой + ",";
		КонецЕсли;
		СтруктураСтрокой = СтруктураСтрокой + Колонка.Имя;
		НужнаЗапятая = Истина;
	КонецЦикла;
	Для Каждого Строка Из ТаблицаЗначений Цикл
		НоваяСтрока = Новый Структура(СтруктураСтрокой);
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
		Массив.Добавить(НоваяСтрока);
	КонецЦикла;
	Возврат Массив;

КонецФункции

// Функция СтрокаТаблицыЗначенийВСтруктуру создает
// структуру со свойствами, как колонки таблицы
// значений передаваемой строки
// и устанавливает этим свойствам значения
// из строки таблицы значений
// 
// Параметры:
//  СтрокаТаблицыЗначений - СтрокаТаблицыЗначений
//
// ВозвращаемоеЗначение:
//  Структура
//
Функция СтрокаТаблицыЗначенийВСтруктуру(СтрокаТаблицыЗначений) Экспорт
	
	Структура = Новый Структура;
	Для каждого Колонка Из СтрокаТаблицыЗначений.Владелец().Колонки Цикл
		Структура.Вставить(Колонка.Имя, СтрокаТаблицыЗначений[Колонка.Имя]);
	КонецЦикла;
	
	Возврат Структура;
	
КонецФункции

// Получает строку, содержащую ключи структуры, разделенные символом разделителя.
//
// Параметры:
//	Структура - Структура - Структура, ключи которой преобразуются в строку
//	Разделитель - Строка - Разделитель, который вставляется в строку между ключами структуры
//
// Возвращаемое значение:
//	Строка - Строка, содержащая ключи структуры разделенные резделителем
//
Функция КлючиСтруктурыВСтроку(Структура, Разделитель = ",") Экспорт
	
	Результат = "";
	
	Для Каждого Элемент Из Структура Цикл
		
		СимволРазделителя = ?(ПустаяСтрока(Результат), "", Разделитель);
		
		Результат = Результат + СимволРазделителя + Элемент.Ключ;
		
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Создает структуру аналогичную менеджеру записи регистра сведений
// 
// Параметры:
//	МенеджерЗаписи - РегистрСведенийМенеджерЗаписи,
//	МетаданныеРегистра - метаданные регистра сведений
//
Функция СтруктураПоМенеджеруЗаписи(МенеджерЗаписи, МетаданныеРегистра) Экспорт
	
	ЗаписьКакСтруктура = Новый Структура;
	
	Если МетаданныеРегистра.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
		ЗаписьКакСтруктура.Вставить("Период", МенеджерЗаписи.Период);
	КонецЕсли;
	Для Каждого Поле Из МетаданныеРегистра.Измерения Цикл
		ЗаписьКакСтруктура.Вставить(Поле.Имя, МенеджерЗаписи[Поле.Имя]);
	КонецЦикла;
	Для Каждого Поле Из МетаданныеРегистра.Ресурсы Цикл
		ЗаписьКакСтруктура.Вставить(Поле.Имя, МенеджерЗаписи[Поле.Имя]);
	КонецЦикла;
	Для Каждого Поле Из МетаданныеРегистра.Реквизиты Цикл
		ЗаписьКакСтруктура.Вставить(Поле.Имя, МенеджерЗаписи[Поле.Имя]);
	КонецЦикла;
	
	Возврат ЗаписьКакСтруктура;
	
КонецФункции

// Создает массив и копирует в него значения, содержащиеся в колонке коллекции строк
//
// Параметры:
//	КоллекцияСтрок - коллекция, для которой доступен обход посредством  
//		оператора Для каждого … Из … Цикл
//	ИмяКолонки - строка с именем поля коллекции, значения которого нужно выгрузить
//	ТолькоУникальныеЗначения - булево, необязательный, если истина, 
//		то в массив будут включены только различающиеся значения 
//
Функция ВыгрузитьКолонку(КоллекцияСтрок, ИмяКолонки, ТолькоУникальныеЗначения = Ложь) Экспорт

	МассивЗначений = Новый Массив;
	
	УникальныеЗначения = Новый Соответствие;
	
	Для каждого СтрокаКоллекции Из КоллекцияСтрок Цикл
		Значение = СтрокаКоллекции[ИмяКолонки];
		Если ТолькоУникальныеЗначения И УникальныеЗначения[Значение] <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		МассивЗначений.Добавить(Значение);
		УникальныеЗначения.Вставить(Значение, Истина);
	КонецЦикла; 
	
	Возврат МассивЗначений;
	
КонецФункции

// Преобразует текст формата XML в таблицу значений,
// при этом колонки таблицы формируются на основе описания в XML.
//
// Параметры:
//  ТекстXML     - текст в формате XML.
//
// Схема XML:
//<?xml version="1.0" encoding="utf-8"?>
//<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" xmlns:xs="http://www.w3.org/2001/XMLSchema">
//  <xs:element name="Items">
//	<xs:complexType>
//	  <xs:sequence>
//		<xs:element maxOccurs="unbounded" name="Item">
//		  <xs:complexType>
//			<xs:attribute name="Code" type="xs:integer" use="required" />
//			<xs:attribute name="Name" type="xs:string" use="required" />
//			<xs:attribute name="Socr" type="xs:string" use="required" />
//			<xs:attribute name="Index" type="xs:string" use="required" />
//		  </xs:complexType>
//		</xs:element>
//	  </xs:sequence>
//	  <xs:attribute name="Description" type="xs:string" use="required" />
//	  <xs:attribute name="Columns" type="xs:string" use="required" />
//	</xs:complexType>
//  </xs:element>
//</xs:schema>
//
// Примеры XML-файлов см. в демонстрационной конфигурации.
// 
// Пример использования:
//   КлассификаторТаблица = ПрочитатьXMLВТаблицу(РегистрыСведений.АдресныйКлассификатор.
//       ПолучитьМакет("КлассификаторАдресныхОбъектовРоссии").ПолучитьТекст());
//
// Возвращаемое значение:
//  ТаблицаЗначений.
//
Функция ПрочитатьXMLВТаблицу(ТекстXML) Экспорт
	
	Чтение = Новый ЧтениеXML;
	Чтение.УстановитьСтроку(ТекстXML);
	
	// Прочитаем первый узел и проверим его
	Если Не Чтение.Прочитать() Тогда
		ВызватьИсключение("Пустой XML");
	ИначеЕсли Чтение.Имя <> "Items" Тогда
		ВызватьИсключение("Ошибка в структуре XML");
	КонецЕсли;
	
	// Получим описание таблицы и создадим ее
	ИмяТаблицы = Чтение.ПолучитьАтрибут("Description");
	ИменаКолонок = СтрЗаменить(Чтение.ПолучитьАтрибут("Columns"), ",", Символы.ПС);
	Колонок = СтрЧислоСтрок(ИменаКолонок);
	
	ТаблицаЗначений = Новый ТаблицаЗначений;
	Для Сч = 1 По Колонок Цикл
		ТаблицаЗначений.Колонки.Добавить(СтрПолучитьСтроку(ИменаКолонок, Сч), Новый ОписаниеТипов("Строка"));
	КонецЦикла;
	
	// Заполним значения в таблице
	Пока Чтение.Прочитать() Цикл
		
		Если Чтение.ТипУзла <> ТипУзлаXML.НачалоЭлемента Тогда
			Продолжить;
		ИначеЕсли Чтение.Имя <> "Item" Тогда
			ВызватьИсключение("Ошибка в структуре XML");
		КонецЕсли;
		
		новСтр = ТаблицаЗначений.Добавить();
		Для Сч = 1 По Колонок Цикл
			ИмяКолонки = СтрПолучитьСтроку(ИменаКолонок, Сч);
			новСтр[Сч-1] = Чтение.ПолучитьАтрибут(ИмяКолонки);
		КонецЦикла;
		
	КонецЦикла;
	
	// Заполним результат
	Результат = Новый Структура;
	Результат.Вставить("ИмяТаблицы", ИмяТаблицы);
	Результат.Вставить("Данные", ТаблицаЗначений);
	
	Возврат Результат;
	
КонецФункции // ПрочитатьXMLВТаблицу()

// Функция выполняет сравнение двух коллекций строк, для которых доступен обход 
// посредством оператора Для каждого … Из … Цикл.
// Сравниваемые коллекции должны отвечать следующим требованиям:
//	- доступен обход посредством оператора Для каждого … Из … Цикл,
//	- наличие в обеих коллекциях всех колонок, перечисленных в параметре ИменаКолонок 
//  (если ИменаКолонок не заполнен - всех колонок)
//
// Параметры:
//	КоллекцияСтрок1 - коллекция, отвечающая вышеописанным требованиям
//	КоллекцияСтрок2 - коллекция, отвечающая вышеописанным требованиям
//	ИменаКолонок 	- строка, разделенная запятыми - имена колонок, 
//						по которым производится сравнение. 
//						Не является обязательным для коллекций, 
//						состав колонок которых можно выявить: 
//						ТаблицаЗначений, СписокЗначений, Соответствие, Структура,
//						если не указан - сравнение производится по всем колонкам.
//						Для коллекций других типов является обязательным
//	ИсключаяКолонки	- имена колонок, которые игнорируются при сравнении, необязательный
//	УчитыватьПоследовательностьСтрок - булево, если Истина, то коллекции признаются 
//						идентичными только если одинаковые строки размещены 
//						в коллекциях на одинаковых местах
//
Функция КоллекцииИдентичны(КоллекцияСтрок1, КоллекцияСтрок2, ИменаКолонок = "", ИсключаяКолонки = "", УчитыватьПоследовательностьСтрок = Ложь) Экспорт
	
	// Типы коллекций, для которых доступен состав колонок, 
	// и можно выявить, если он не задан
	ТипыОсобыхКоллекций = Новый Массив;
	ТипыОсобыхКоллекций.Добавить(Тип("ТаблицаЗначений"));
	ТипыОсобыхКоллекций.Добавить(Тип("СписокЗначений"));
	
	ТипыКоллекцийКлючИЗначение = Новый Массив;
	ТипыКоллекцийКлючИЗначение.Добавить(Тип("Соответствие"));
	ТипыКоллекцийКлючИЗначение.Добавить(Тип("Структура"));
	ТипыКоллекцийКлючИЗначение.Добавить(Тип("ФиксированноеСоответствие"));
	ТипыКоллекцийКлючИЗначение.Добавить(Тип("ФиксированнаяСтруктура"));
	
	Если ПустаяСтрока(ИменаКолонок) Тогда
		Если ТипыОсобыхКоллекций.Найти(ТипЗнч(КоллекцияСтрок1)) <> Неопределено 
			Или ТипыКоллекцийКлючИЗначение.Найти(ТипЗнч(КоллекцияСтрок1)) <> Неопределено Тогда
			СравниваемыеКолонки = Новый Массив;
			Если ТипЗнч(КоллекцияСтрок1) = Тип("ТаблицаЗначений") Тогда
				Для Каждого Колонка Из КоллекцияСтрок1.Колонки Цикл
					СравниваемыеКолонки.Добавить(Колонка.Имя);
				КонецЦикла;
			ИначеЕсли ТипЗнч(КоллекцияСтрок1) = Тип("СписокЗначений") Тогда
				СравниваемыеКолонки.Добавить("Значение");
				СравниваемыеКолонки.Добавить("Картинка");
				СравниваемыеКолонки.Добавить("Пометка");
				СравниваемыеКолонки.Добавить("Представление");
			ИначеЕсли ТипыКоллекцийКлючИЗначение.Найти(ТипЗнч(КоллекцияСтрок1)) <> Неопределено Тогда
				СравниваемыеКолонки.Добавить("Ключ");
				СравниваемыеКолонки.Добавить("Значение");
			КонецЕсли;
		Иначе
			ТекстИсключения = НСтр("ru = 'Для коллекции типа %1 необходимо указать имена полей, по которым производится сравнение'");
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстИсключения, ТипЗнч(КоллекцияСтрок1));
		КонецЕсли;
	Иначе
		СравниваемыеКолонки = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИменаКолонок);
	КонецЕсли;

	// Вычитаем исключаемые поля
	СравниваемыеКолонки = ОбщегоНазначенияКлиентСервер.СократитьМассив(СравниваемыеКолонки, 
						СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИсключаяКолонки));
						
	Если УчитыватьПоследовательностьСтрок Тогда
		
		// Параллельный обход обеих коллекций
		НомерСтрокиКоллекции1 = 0;
		Для Каждого СтрокаКоллекции1 Из КоллекцияСтрок1 Цикл
			// Спозиционируемся на аналогичную строку второй коллекции
			НомерСтрокиКоллекции2 = 0;
			ЕстьСтрокиКоллекции2 = Ложь;
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				ЕстьСтрокиКоллекции2 = Истина;
				Если НомерСтрокиКоллекции2 = НомерСтрокиКоллекции1 Тогда
					Прервать;
				КонецЕсли;
				НомерСтрокиКоллекции2 = НомерСтрокиКоллекции2 + 1;
			КонецЦикла;
			Если Не ЕстьСтрокиКоллекции2 Тогда
				// Во второй коллекции вообще нет строк
				Возврат Ложь;
			КонецЕсли;
			// Сравниваем значения полей двух строк
			Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
				Если СтрокаКоллекции1[ИмяКолонки] <> СтрокаКоллекции2[ИмяКолонки] Тогда
					Возврат Ложь;
				КонецЕсли;
			КонецЦикла;
			НомерСтрокиКоллекции1 = НомерСтрокиКоллекции1 + 1;
		КонецЦикла;
		
		КоличествоСтрокКоллекции1 = НомерСтрокиКоллекции1;
		
		// Отдельно подсчитаем количество строк второй коллекции
		КоличествоСтрокКоллекции2 = 0;
		Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
			КоличествоСтрокКоллекции2 = КоличествоСтрокКоллекции2 + 1;
		КонецЦикла;
		
		// Если в первой коллекции не оказалось строк, 
		// то их не должно быть и во второй
		Если КоличествоСтрокКоллекции1 = 0 Тогда
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				Возврат Ложь;
			КонецЦикла;
			КоличествоСтрокКоллекции2 = 0;
		КонецЕсли;
		
		// Количество строк не должно отличаться
		Если КоличествоСтрокКоллекции1 <> КоличествоСтрокКоллекции2 Тогда
			Возврат Ложь;
		КонецЕсли;
		
	Иначе
	
		// Проверяем идентичность состава одинаковых строк без учета их последовательности
		
		// Строки отбора накапливаем по первой коллекции для того, чтобы:
		//  - повторно не искать одинаковые строки,
		//  - убедиться, что во второй коллекции ни одной такой строки, которой нет в накопленных
		
		СтрокиОтбора = Новый ТаблицаЗначений;
		ПараметрыОтбора = Новый Структура;
		Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
			СтрокиОтбора.Колонки.Добавить(ИмяКолонки);
			ПараметрыОтбора.Вставить(ИмяКолонки);
		КонецЦикла;
		
		ЕстьСтрокиКоллекции1 = Ложь;
		Для Каждого СтрокаОтбора Из КоллекцияСтрок1 Цикл
			
			ЗаполнитьЗначенияСвойств(ПараметрыОтбора, СтрокаОтбора);
			Если СтрокиОтбора.НайтиСтроки(ПараметрыОтбора).Количество() > 0 Тогда
				// строку с такими полями уже искали
				Продолжить;
			КонецЕсли;
			ЗаполнитьЗначенияСвойств(СтрокиОтбора.Добавить(), СтрокаОтбора);
			
			// Подсчитаем количество таких строк в первой коллекции
			НайденоСтрокКоллекции1 = 0;
			Для Каждого СтрокаКоллекции1 Из КоллекцияСтрок1 Цикл
				СтрокаПодходит = Истина;
				Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
					Если СтрокаКоллекции1[ИмяКолонки] <> СтрокаОтбора[ИмяКолонки] Тогда
						СтрокаПодходит = Ложь;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				Если СтрокаПодходит Тогда
					НайденоСтрокКоллекции1 = НайденоСтрокКоллекции1 + 1;
				КонецЕсли;
			КонецЦикла;
			
			// Подсчитаем количество таких строк во второй коллекции
			НайденоСтрокКоллекции2 = 0;
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				СтрокаПодходит = Истина;
				Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
					Если СтрокаКоллекции2[ИмяКолонки] <> СтрокаОтбора[ИмяКолонки] Тогда
						СтрокаПодходит = Ложь;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				Если СтрокаПодходит Тогда
					НайденоСтрокКоллекции2 = НайденоСтрокКоллекции2 + 1;
					// Если количество таких строк во второй коллекции превысило количество в первой, 
					// то уже можно сделать вывод, что коллекции не идентичны
					Если НайденоСтрокКоллекции2 > НайденоСтрокКоллекции1 Тогда
						Возврат Ложь;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			
			// Количество таких строк не должно отличаться
			Если НайденоСтрокКоллекции1 <> НайденоСтрокКоллекции2 Тогда
				Возврат Ложь;
			КонецЕсли;
			
			ЕстьСтрокиКоллекции1 = Истина;
			
		КонецЦикла;
		
		// Если в первой коллекции не оказалось строк, 
		// то их не должно быть и во второй
		Если Не ЕстьСтрокиКоллекции1 Тогда
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				Возврат Ложь;
			КонецЦикла;
		КонецЕсли;
		
		// Проверим, что во второй коллекции нет ни одной такой строки, которой нет в накопленных
		Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
			ЗаполнитьЗначенияСвойств(ПараметрыОтбора, СтрокаКоллекции2);
			Если СтрокиОтбора.НайтиСтроки(ПараметрыОтбора).Количество() = 0 Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
	
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Математические процедуры и функции

// Выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения.
//
// Параметры:
//		ИсхСумма   - распределяемая сумма
//		МассивКоэф - массив коэффициентов распределения
//		Точность   - точность округления при распределении. Необязателен.
//
//	Возврат:
//		МассивСумм - массив размерностью равный массиву коэффициентов, содержит
//			суммы в соответствии с весом коэффициента (из массива коэффициентов)
//          В случае если распределить не удалось (сумма = 0, кол-во коэф. = 0,
//          или суммарный вес коэф. = 0), тогда возвращается значение Неопределено
//
Функция РаспределитьСуммуПропорциональноКоэффициентам(Знач ИсхСумма, МассивКоэф, Знач Точность = 2) Экспорт
	
	Если МассивКоэф.Количество() = 0 Или НЕ ЗначениеЗаполнено(ИсхСумма) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ИндексМакс = 0;
	МаксЗнач   = 0;
	РаспрСумма = 0;
	СуммаКоэф  = 0;
	
	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		
		МодульЧисла = ?(МассивКоэф[К] > 0, МассивКоэф[К], - МассивКоэф[К]);
		
		Если МаксЗнач < МодульЧисла Тогда
			МаксЗнач = МодульЧисла;
			ИндексМакс = К;
		КонецЕсли;
		
		СуммаКоэф = СуммаКоэф + МассивКоэф[К];
		
	КонецЦикла;
	
	Если СуммаКоэф = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МассивСумм = Новый Массив(МассивКоэф.Количество());
	
	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		МассивСумм[К] = Окр(ИсхСумма * МассивКоэф[К] / СуммаКоэф, Точность, 1);
		РаспрСумма = РаспрСумма + МассивСумм[К];
	КонецЦикла;
	
	// Погрешности округления отнесем на коэффицент с максимальным весом
	Если Не РаспрСумма = ИсхСумма Тогда
		МассивСумм[ИндексМакс] = МассивСумм[ИндексМакс] + ИсхСумма - РаспрСумма;
	КонецЕсли;
	
	Возврат МассивСумм;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с внешним соединением

// Возвращает имя COM-класса для работы с 1С:Предприятием 8 через COM-соединение.
//
Функция ИмяCOMСоединителя() Экспорт
	
	СистемнаяИнфо = Новый СистемнаяИнформация;
	ПодстрокиВерсии = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(
		СистемнаяИнфо.ВерсияПриложения, ".");
	Возврат "v" + ПодстрокиВерсии[0] + ПодстрокиВерсии[1] + ".COMConnector";
	
КонецФункции	

// Устанавливает внешнее соединение с информационной базой по переданным параметрам подключения и возвращает указатель на это соединение
// 
// Параметры:
//  Параметры - Структура - содержит параметры для установки внешнего соединения с информационной базой.
//  Структура должна содержать следующие ключи (см. функция ОбщегоНазначенияКлиентСервер.СтруктураПараметровДляУстановкиВнешнегоСоединения):
//
//	  ВариантРаботыИнформационнойБазы             - (Число)  Вариант работы информационной базы: 0 – файловый; 1 – клиент-серверный
//	  КаталогИнформационнойБазы                   - (Строка) Каталог информационной базы для файлового режима работы
//	  ИмяСервера1СПредприятия                     - (Строка) Имя сервера1С:Предприятия
//	  ИмяИнформационнойБазыНаСервере1СПредприятия - (Строка) Имя информационной базы на сервере1С:Предприятия
//	  АутентификацияОперационнойСистемы           - (Булево) Признак аутентификации операционной системы при создании внешнего подключения к информационной базе
//	  ИмяПользователя                             - (Строка) Имя пользователя информационной базы
//	  ПарольПользователя                          - (Строка) Пароль пользователя информационной базы
// 
//  СтрокаСообщенияОбОшибке (необязательный) – Строка – если в процессе установки внешнего соединения возникает ошибка,
//                                                     то подробное описание ошибки помещается в этот параметр
//
// Возвращаемое значение:
//  Тип: COM-объект, Неопределенно.
//  в случае успешной установки внешнего соединения возвращается указатель на COM-объект соединения;
//  в случае ошибки возвращается Неопределенно.
//
Функция УстановитьВнешнееСоединение(Параметры, СтрокаСообщенияОбОшибке = "", ОшибкаПодключенияКомпоненты = Ложь) Экспорт
	
	// возвращаемое значение функции (COM-объект)
	Connection = Неопределено;
	
	Попытка
		COMConnector = Новый COMObject(ИмяCOMСоединителя()); // "V83.COMConnector"
	Исключение
		СтрокаСообщенияОбОшибке = НСтр("ru = 'При установке внешнего соединения произошла ошибка: %1'");
		СтрокаСообщенияОбОшибке = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ОшибкаПодключенияКомпоненты = Истина;
		Возврат Неопределено;
	КонецПопытки;
	
	Если Параметры.ВариантРаботыИнформационнойБазы = 0 Тогда
		
		Если ПустаяСтрока(Параметры.КаталогИнформационнойБазы) Тогда
			
			СтрокаСообщенияОбОшибке = НСтр("ru = 'Не задано месторасположение каталога информационной базы.'");
			Возврат Неопределено;
			
		КонецЕсли;
		
		Если Параметры.АутентификацияОперационнойСистемы Тогда
			
			СтрокаСоединения = "File = ""&КаталогИнформационнойБазы""";
			
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&КаталогИнформационнойБазы", Параметры.КаталогИнформационнойБазы);
			
		Иначе
			
			СтрокаСоединения = "File = ""&КаталогИнформационнойБазы""; Usr = ""&ИмяПользователя""; Pwd = ""&ПарольПользователя""";
			
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&КаталогИнформационнойБазы", Параметры.КаталогИнформационнойБазы);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяПользователя",           Параметры.ИмяПользователя);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ПарольПользователя",        Параметры.ПарольПользователя);
			
		КонецЕсли;
		
	Иначе // Клиент-серверный вариант работы информационной базы
		
		Если    ПустаяСтрока(Параметры.ИмяСервера1СПредприятия)
			ИЛИ ПустаяСтрока(Параметры.ИмяИнформационнойБазыНаСервере1СПредприятия) Тогда
			
			СтрокаСообщенияОбОшибке = НСтр("ru = 'Не заданы обязательные параметры подключения: ""Имя сервера""; ""Имя информационной базы на сервере"".'");
			Возврат Неопределено;
			
		КонецЕсли;
		
		Если Параметры.АутентификацияОперационнойСистемы Тогда
			
			СтрокаСоединения = "Srvr = &ИмяСервера1СПредприятия; Ref = &ИмяИнформационнойБазыНаСервере1СПредприятия";
			
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяСервера1СПредприятия",                     Параметры.ИмяСервера1СПредприятия);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяИнформационнойБазыНаСервере1СПредприятия", Параметры.ИмяИнформационнойБазыНаСервере1СПредприятия);
			
		Иначе
			
			СтрокаСоединения = "Srvr = &ИмяСервера1СПредприятия; Ref = &ИмяИнформационнойБазыНаСервере1СПредприятия; Usr = ""&ИмяПользователя""; Pwd = ""&ПарольПользователя""";
			
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяСервера1СПредприятия",                     Параметры.ИмяСервера1СПредприятия);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяИнформационнойБазыНаСервере1СПредприятия", Параметры.ИмяИнформационнойБазыНаСервере1СПредприятия);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяПользователя",                             Параметры.ИмяПользователя);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ПарольПользователя",                          Параметры.ПарольПользователя);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Попытка
		Connection = COMConnector.Connect(СтрокаСоединения);
	Исключение
		
		ОшибкаПодключенияКомпоненты = Истина;
		
		ПодробноеПредставлениеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		
		СтрокаСообщенияОбОшибке = НСтр("ru = 'При установке внешнего соединения произошла ошибка: %1'");
		СтрокаСообщенияОбОшибке = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, ПодробноеПредставлениеОшибки);
		Возврат Неопределено;
	КонецПопытки;
	
	Возврат Connection;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Вспомогательные процедуры и функции

// Выполнить экспортную процедуру по имени.
//
// Параметры
//  ИмяЭкспортнойПроцедуры – Строка    – имя экспортной процедуры в формате 
//										 <имя объекта>.<имя процедуры>, где <имя объекта> - это
// 										 общий модуль или модуль менеджера объекта.
// Параметры               - Массив    - параметры передаются в процедуру <ИмяЭкспортнойПроцедуры>
//                                       в порядке расположения элементов массива.
// ОбластьДанных           - Число     - задает область данных, в которой необходимо выполнить процедуру.
// 
// Пример:
//  ВыполнитьБезопасно("МойОбщийМодуль.МояПроцедура"); 
//
Процедура ВыполнитьБезопасно(ИмяЭкспортнойПроцедуры, Параметры = Неопределено, ОбластьДанных = Неопределено) Экспорт
	
	// Проверка предусловий на формат ИмяЭкспортнойПроцедуры.       
	ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЭкспортнойПроцедуры, ".");
	Если ЧастиИмени.Количество() <> 2 И ЧастиИмени.Количество() <> 3 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
			ИмяЭкспортнойПроцедуры);
	КонецЕсли;

	ИмяОбъекта = ЧастиИмени[0];
	Если ЧастиИмени.Количество() = 2 И Метаданные.ОбщиеМодули.Найти(ИмяОбъекта) = Неопределено Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
			ИмяЭкспортнойПроцедуры);
	КонецЕсли;
		
	Если ЧастиИмени.Количество() = 3 Тогда
		ДопустимыеИменаТипов = Новый Массив;
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаКонстанты()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыСведений()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыНакопления()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыБухгалтерии()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыРасчета()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаСправочники()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаДокументы()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаОтчеты()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаОбработки()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаБизнесПроцессы()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаЗадачи()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыСчетов()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыОбмена()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыВидовХарактеристик()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыВидовРасчета()));
		ИмяТипа = ВРег(ЧастиИмени[0]);
		Если ДопустимыеИменаТипов.Найти(ИмяТипа) = Неопределено Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
				ИмяЭкспортнойПроцедуры);
		КонецЕсли;
	КонецЕсли;
	
	ИмяМетода = ЧастиИмени[ЧастиИмени.ВГраница()];
	ВременнаяСтруктура = Новый Структура;
	Попытка
		// Проверка на то, что ИмяМетода является допустимым идентификатором.
		// Например: МояПроцедура
		ВременнаяСтруктура.Вставить(ИмяМетода);
	Исключение
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Безопасное выполнение метода'"), УровеньЖурналаРегистрации.Ошибка, , ,
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
			ИмяЭкспортнойПроцедуры);
	КонецПопытки;
	
	ПараметрыСтрока = "";
	Если Параметры <> Неопределено И Параметры.Количество() > 0 Тогда
		Для Индекс = 0 По Параметры.ВГраница() Цикл 
			ПараметрыСтрока = ПараметрыСтрока + "Параметры[" + Индекс + "],";
		КонецЦикла;
		ПараметрыСтрока = Сред(ПараметрыСтрока, 1, СтрДлина(ПараметрыСтрока) - 1);
	КонецЕсли;
	
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		Если Не ОбщегоНазначенияПовтИсп.СеансЗапущенБезРазделителей() Тогда
			Если ОбластьДанных = Неопределено Тогда
				ОбластьДанных = ЗначениеРазделителяСеанса();
			Иначе 
				Если ОбластьДанных <> ЗначениеРазделителяСеанса() Тогда
					ВызватьИсключение(НСтр("ru = 'В данном сеансе недопустимо обращение к данным из другой области данных!'"));
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Если ОбластьДанных <> Неопределено
			И (НЕ ИспользованиеРазделителяСеанса() ИЛИ ОбластьДанных <> ЗначениеРазделителяСеанса()) Тогда
			УстановитьРазделениеСеанса(Истина, ОбластьДанных);
		КонецЕсли;
	КонецЕсли;
	
	Выполнить ИмяЭкспортнойПроцедуры + "(" + ПараметрыСтрока + ")";
	
КонецПроцедуры

// Проверяет имя экспортной процедуры на валидность для использования
// в инструкции Выполнить встроенного языка. При некорректном имени
// вызывается исключение.
//
Функция ПроверитьИмяЭкспортнойПроцедуры(Знач ИмяЭкспортнойПроцедуры, ТекстСообщения) Экспорт
	
	// Проверка предусловий на формат ИмяЭкспортнойПроцедуры.
	ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЭкспортнойПроцедуры, ".");
	Если ЧастиИмени.Количество() <> 2 И ЧастиИмени.Количество() <> 3 Тогда
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
			ИмяЭкспортнойПроцедуры);
		Возврат Ложь;
	КонецЕсли;

	ИмяОбъекта = ЧастиИмени[0];
	Если ЧастиИмени.Количество() = 2 И Метаданные.ОбщиеМодули.Найти(ИмяОбъекта) = Неопределено Тогда
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
			ИмяЭкспортнойПроцедуры);
		Возврат Ложь;
	КонецЕсли;
		
	Если ЧастиИмени.Количество() = 3 Тогда
		ДопустимыеИменаТипов = Новый Массив;
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаКонстанты()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыСведений()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыНакопления()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыБухгалтерии()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыРасчета()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаСправочники()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаДокументы()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаБизнесПроцессы()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаЗадачи()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыСчетов()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыОбмена()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыВидовХарактеристик()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыВидовРасчета()));
		ИмяТипа = ВРег(ЧастиИмени[0]);
		Если ДопустимыеИменаТипов.Найти(ИмяТипа) = Неопределено Тогда
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
				ИмяЭкспортнойПроцедуры);
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Функция ИнформационнаяБазаФайловая определяет режим эксплуатации
// информационной базы файловый (Истина) или Серверный (Ложь).
//  При проверке используется СтрокаСоединенияИнформационнойБазы, которую
// можно указать явно.
//
// Параметры:
//  СтрокаСоединенияИнформационнойБазы - Строка - параметр используется, если
//                 нужно проверить строку соединения не текущей информационной базы.
//
// Возвращаемое значение:
//  Булево.
//
Функция ИнформационнаяБазаФайловая(Знач СтрокаСоединенияИнформационнойБазы = "") Экспорт
			
	Если ПустаяСтрока(СтрокаСоединенияИнформационнойБазы) Тогда
		СтрокаСоединенияИнформационнойБазы =  СтрокаСоединенияИнформационнойБазы();
	КонецЕсли;
	Возврат Найти(Врег(СтрокаСоединенияИнформационнойБазы), "FILE=") = 1;
	
КонецФункции 

// Переводит параметры сеанса в состояние "Не установлено". 
// 
// Параметры: 
// ПараметрыДляОчистки - Строка - имена параметров сеанса для очистки, разделенные ","
// Исключения          - Строка - имена параметров сеанса не предназначенные для очистки, разделенные ","
//
Процедура ОчиститьПараметрыСеанса(ПараметрыДляОчистки = "", Исключения = "") Экспорт
	
	МассивИсключений           = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Исключения);
	МассивПараметровДляОчистки = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПараметрыДляОчистки);
	
	Если МассивПараметровДляОчистки.Количество() = 0 Тогда
		Для Каждого ПараметрСеанса Из Метаданные.ПараметрыСеанса Цикл
			Если МассивИсключений.Найти(ПараметрСеанса.Имя) = Неопределено Тогда
				МассивПараметровДляОчистки.Добавить(ПараметрСеанса.Имя);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	ПараметрыСеанса.Очистить(МассивПараметровДляОчистки);
	
КонецПроцедуры

// Возвращает описание предмета в виде текстовой строки.
// 
// Параметры
//  СсылкаНаПредмет  – ЛюбаяСсылка – объект ссылочного типа.
//
// Возвращаемое значение:
//   Строка 
// 
Функция ПредметСтрокой(СсылкаНаПредмет) Экспорт
	
	Результат = "";
	СтандартныеПодсистемыПереопределяемый.УстановитьПредставлениеПредмета(СсылкаНаПредмет, Результат); 
	ОбщегоНазначенияПереопределяемый.УстановитьПредставлениеПредмета(СсылкаНаПредмет, Результат); 
	
	Если ПустаяСтрока(Результат) Тогда
		Если СсылкаНаПредмет = Неопределено или СсылкаНаПредмет.Пустая() Тогда
			Результат = НСтр("ru = 'не задан'");
		ИначеЕсли Метаданные.Документы.Содержит(СсылкаНаПредмет.Метаданные()) Тогда
			Результат = Строка(СсылкаНаПредмет);
		Иначе
			ПредставлениеОбъекта = СсылкаНаПредмет.Метаданные().ПредставлениеОбъекта;
			Если ПустаяСтрока(ПредставлениеОбъекта) Тогда
				ПредставлениеОбъекта = СсылкаНаПредмет.Метаданные().Представление();
			КонецЕсли;
			Результат = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				"%1 (%2)", Строка(СсылкаНаПредмет), ПредставлениеОбъекта);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Объединяет исключения поиска ссылок.
//
Функция ПолучитьОбщийСписокИсключенийПоискаСсылок() Экспорт
	
	ОбщийМассивИсключенийСсылок = Новый Массив;
	
	ЗаполнитьМассивУникальнымиЗначениями(ОбщийМассивИсключенийСсылок, СтандартныеПодсистемыПереопределяемый.ИсключенияПоискаСсылок());
	ЗаполнитьМассивУникальнымиЗначениями(ОбщийМассивИсключенийСсылок, ОбщегоНазначенияПереопределяемый.ПолучитьИсключенияПоискаСсылок());
	
	Возврат ОбщийМассивИсключенийСсылок;
	
КонецФункции

// Функция создает таблицу соответствия разделенных типов данных общим данным
//
// Возвращаемое значение:
// ТаблицаЗначений - соответствия типов данных
//
Функция ПолучитьТаблицуСоответствияРазделенныхДанныхОбщим() Экспорт
	
	Результат = СтандартныеПодсистемыПереопределяемый.ТаблицаСоответствияРазделенныхДанныхОбщим();
	Если Результат = Неопределено Тогда
		Возврат Новый ТаблицаЗначений;
	Иначе
		Возврат Результат;
	КонецЕсли;
	
КонецФункции

// Возвращает значение в виде XML-строки.
// Преобразованы в XML-строку (сериализованы) могут быть только те объекты, 
// для которых в описании указано, что они сериализуются.
//
// Параметры:
// Значение – Произвольный. Значение, которое необходимо сериализовать в XML-строку.
//
// Возвращаемое значение:
// XML-строка представления значения в сериализованном виде.
//
Функция ЗначениеВСтрокуXML(Значение) Экспорт
	
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьXML(ЗаписьXML, Значение, НазначениеТипаXML.Явное);
	
	Возврат ЗаписьXML.Закрыть();
КонецФункции

// Возвращает значение, полученное из XML-строки. 
// Получены из XML-строки могут быть только те объекты, 
// для которых в описании указано, что они сериализуются.
//
// Параметры:
// СтрокаXML – строка представления значения в сериализованном виде.
//
// Возвращаемое значение:
// Значение, полученное из переданной XML-строки.
//
Функция ЗначениеИзСтрокиXML(СтрокаXML) Экспорт
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаXML);
	
	Возврат СериализаторXDTO.ПрочитатьXML(ЧтениеXML);
КонецФункции

// Формирует из исходной строки СтрокаПоиска строку для поиска данных в запросе
//
// Параметры:
//	СтрокаПоиска - Строка - исходная строка, содержащая запрещенные символы 	
//
// Возвращаемое значение:
//  Строка - строка подготовленная для поиска данных в запросе
//
Функция СформироватьСтрокуДляПоискаВЗапросе(Знач СтрокаПоиска) Экспорт
	
	ИтоговаяСтрокаДляПоиска = СтрокаПоиска;
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "~", "~~");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "%", "~%");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "_", "~_");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "[", "~[");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "-", "~-");
	
	Возврат ИтоговаяСтрокаДляПоиска;
	
КонецФункции

// Функция возвращает объект WSПрокси созданный с переданными параметрами.
//
// Параметры:
//  АдресWSDL - Строка - местораположение wsdl
//  URIПространстваИмен - Строка - URI пространства имен web-сервиса
//  ИмяСервиса - Строка - имя сервиса
//  ИмяТочкиПодключения - Строка - если не задано, образуется как <ИмяСервиса>Soap
//  ИмяПользователя - Строка - имя пользователя для входа на сервер
//  Пароль - Строка - пароль пользователя
//  Таймаут - Число - таймаут на операции выполняемые через полученное прокси 
//
// Возвращаемое значение:
//  WSПрокси
//
Функция WSПрокси(
			Знач АдресWSDL,
			Знач URIПространстваИмен,
			Знач ИмяСервиса,
			Знач ИмяТочкиПодключения = "",
			Знач ИмяПользователя,
			Знач Пароль,
			Знач Таймаут = Неопределено,
			Знач ДелатьКонтрольныйВызов = Ложь
	) Экспорт
	
	Если ДелатьКонтрольныйВызов И Таймаут <> Неопределено И Таймаут > 20 Тогда
		
		WSПроксиPing = ОбщегоНазначенияПовтИсп.WSПрокси(
			АдресWSDL,
			URIПространстваИмен,
			ИмяСервиса,
			ИмяТочкиПодключения,
			ИмяПользователя,
			Пароль,
			3
		);
		
		Попытка
			WSПроксиPing.Ping();
		Исключение
			ЗаписьЖурналаРегистрации(НСтр("ru = 'WSПрокси'"),
				УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке())
			);
			ВызватьИсключение;
		КонецПопытки;
		
	КонецЕсли;
	
	Возврат ОбщегоНазначенияПовтИсп.WSПрокси(
		АдресWSDL,
		URIПространстваИмен,
		ИмяСервиса,
		ИмяТочкиПодключения,
		ИмяПользователя,
		Пароль,
		Таймаут
	);
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с формами

// Процедура предназначена для заполнения реквизита формы типа «ДеревоЗначений»
//
// Параметры:
// КоллекцияЭлементовДерева – реквизит формы, который имеет тип «ДеревоЗначений»;
// 							  реквизит заполняется значениями из второго параметра процедуры.
// ДеревоЗначений           – ДеревоЗначений – параметр содержит данные для заполнения.
// 
Процедура ЗаполнитьКоллекциюЭлементовДереваДанныхФормы(КоллекцияЭлементовДерева, ДеревоЗначений) Экспорт
	
	Для Каждого Строка Из ДеревоЗначений.Строки Цикл
		
		ЭлементДерева = КоллекцияЭлементовДерева.Добавить();
		
		ЗаполнитьЗначенияСвойств(ЭлементДерева, Строка);
		
		Если Строка.Строки.Количество() > 0 Тогда
			
			ЗаполнитьКоллекциюЭлементовДереваДанныхФормы(ЭлементДерева.ПолучитьЭлементы(), Строка);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Получает картинку для вывода на странице с комментарием в зависимости
// от наличия текста в комментарии.
//
// Параметры
//  Комментарий  - Строка - текст комментария
//
// Возвращаемое значение:
//  Картинка - Картинка, которая должна отображаться на странице с комментарием.
//
Функция ПолучитьКартинкуКомментария(Комментарий) Экспорт
	
	Если НЕ ПустаяСтрока(Комментарий) Тогда
		Картинка = БиблиотекаКартинок.Комментарий;
	Иначе
		Картинка = Новый Картинка;
	КонецЕсли;
	
	Возврат Картинка;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с типами, объектами метаданных и их строковыми представлениями.

// Получает дерево метаданных конфигурации с заданным отбором по объектам метаданных.
//
// Параметры:
// Отбор – Структура – содержит значения элементов отбора.
//						Если параметр задан, то будет получено дерево метаданных в соответствии с заданным отбором. 
//						Ключ (Строка) – имя свойства элемента метаданных;
//						Значение (Массив) – множество значений для отбора.
//
// Пример инициализации переменной "Отбор":
//
// Массив = Новый Массив;
// Массив.Добавить("Константа.ИспользоватьОбменДанными");
// Массив.Добавить("Справочник.Валюты");
// Массив.Добавить("Справочник.Организации");
// Отбор = Новый Структура;
// Отбор.Вставить("ПолноеИмя", Массив);
// 
//  Возвращаемое значение:
//  Тип: ДеревоЗначений - дерево описания метаданных конфигурации
//
Функция ПолучитьДеревоМетаданныхКонфигурации(Отбор = Неопределено) Экспорт
	
	ИспользоватьОтбор = (Отбор <> Неопределено);
	
	КоллекцииОбъектовМетаданных = Новый ТаблицаЗначений;
	КоллекцииОбъектовМетаданных.Колонки.Добавить("Имя");
	КоллекцииОбъектовМетаданных.Колонки.Добавить("Синоним");
	КоллекцииОбъектовМетаданных.Колонки.Добавить("Картинка");
	КоллекцииОбъектовМетаданных.Колонки.Добавить("КартинкаОбъекта");
	
	НоваяСтрокаКоллекцииОбъектовМетаданных("Константы",               "Константы",                 БиблиотекаКартинок.Константа,              БиблиотекаКартинок.Константа,                    КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("Справочники",             "Справочники",               БиблиотекаКартинок.Справочник,             БиблиотекаКартинок.Справочник,                   КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("Документы",               "Документы",                 БиблиотекаКартинок.Документ,               БиблиотекаКартинок.ДокументОбъект,               КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыВидовХарактеристик", "Планы видов характеристик", БиблиотекаКартинок.ПланВидовХарактеристик, БиблиотекаКартинок.ПланВидовХарактеристикОбъект, КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыСчетов",             "Планы счетов",              БиблиотекаКартинок.ПланСчетов,             БиблиотекаКартинок.ПланСчетовОбъект,             КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыВидовРасчета",       "Планы видов характеристик", БиблиотекаКартинок.ПланВидовХарактеристик, БиблиотекаКартинок.ПланВидовХарактеристикОбъект, КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыСведений",        "Регистры сведений",         БиблиотекаКартинок.РегистрСведений,        БиблиотекаКартинок.РегистрСведений,              КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыНакопления",      "Регистры накопления",       БиблиотекаКартинок.РегистрНакопления,      БиблиотекаКартинок.РегистрНакопления,            КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыБухгалтерии",     "Регистры бухгалтерии",      БиблиотекаКартинок.РегистрБухгалтерии,     БиблиотекаКартинок.РегистрБухгалтерии,           КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыРасчета",         "Регистры расчета",          БиблиотекаКартинок.РегистрРасчета,         БиблиотекаКартинок.РегистрРасчета,               КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("БизнесПроцессы",          "Бизнес-процессы",           БиблиотекаКартинок.БизнесПроцесс,          БиблиотекаКартинок.БизнесПроцессОбъект,          КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("Задачи",                  "Задачи",                    БиблиотекаКартинок.Задача,                 БиблиотекаКартинок.ЗадачаОбъект,                 КоллекцииОбъектовМетаданных);
	
	// возвращаемое значение функции
	ДеревоМетаданных = Новый ДеревоЗначений;
	ДеревоМетаданных.Колонки.Добавить("Имя");
	ДеревоМетаданных.Колонки.Добавить("ПолноеИмя");
	ДеревоМетаданных.Колонки.Добавить("Синоним");
	ДеревоМетаданных.Колонки.Добавить("Картинка");
	
	Для Каждого СтрокаКоллекции Из КоллекцииОбъектовМетаданных Цикл
		
		СтрокаДерева = ДеревоМетаданных.Строки.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаДерева, СтрокаКоллекции);
		Для Каждого ОбъектМетаданных Из Метаданные[СтрокаКоллекции.Имя] Цикл
			
			Если ИспользоватьОтбор Тогда
				
				ОбъектПрошелФильтр = Истина;
				Для Каждого ЭлементОтбора Из Отбор Цикл
					
					Значение = ?(ВРег(ЭлементОтбора.Ключ) = ВРег("ПолноеИмя"), ОбъектМетаданных.ПолноеИмя(), ОбъектМетаданных[ЭлементОтбора.Ключ]);
					Если ЭлементОтбора.Значение.Найти(Значение) = Неопределено Тогда
						ОбъектПрошелФильтр = Ложь;
						Прервать;
					КонецЕсли;
					
				КонецЦикла;
				
				Если Не ОбъектПрошелФильтр Тогда
					Продолжить;
				КонецЕсли;
				
			КонецЕсли;
			
			СтрокаДереваОМ = СтрокаДерева.Строки.Добавить();
			СтрокаДереваОМ.Имя       = ОбъектМетаданных.Имя;
			СтрокаДереваОМ.ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
			СтрокаДереваОМ.Синоним   = ОбъектМетаданных.Синоним;
			СтрокаДереваОМ.Картинка  = СтрокаКоллекции.КартинкаОбъекта;
			
		КонецЦикла;
		
	КонецЦикла;
	
	// удаляем строки без подчиненных элементов
	Если ИспользоватьОтбор Тогда
		
		// используем обратный порядок обхода дерева значений
		КолвоЭлементовКоллекции = ДеревоМетаданных.Строки.Количество();
		
		Для ОбратныйИндекс = 1 По КолвоЭлементовКоллекции Цикл
			
			ТекущийИндекс = КолвоЭлементовКоллекции - ОбратныйИндекс;
			СтрокаДерева = ДеревоМетаданных.Строки[ТекущийИндекс];
			Если СтрокаДерева.Строки.Количество() = 0 Тогда
				ДеревоМетаданных.Строки.Удалить(ТекущийИндекс);
			КонецЕсли;
			
		КонецЦикла;
	
	КонецЕсли;
	
	Возврат ДеревоМетаданных;
	
КонецФункции

// Получить представление физического места размещения информационной базы для отображения администратору.
//
// Возвращаемое значение:
//   Строка      - представление информационной базы
//
// Пример возвращаемого результата:
// - для ИБ в файлом режиме: \\FileServer\1c_ib\
// - для ИБ в серверном режиме: ServerName:1111 / information_base_name
//
Функция ПолучитьПредставлениеИнформационнойБазы() Экспорт
	
	СтрокаСоединенияСБД = СтрокаСоединенияИнформационнойБазы();
	
	Если ИнформационнаяБазаФайловая(СтрокаСоединенияСБД) Тогда
		Возврат Сред(СтрокаСоединенияСБД, 6, СтрДлина(СтрокаСоединенияСБД) - 6);
	КонецЕсли;
		
	// Прибавить к имени сервера имя пути информационной базы
	ПозицияПоиска = СтрНайти(Врег(СтрокаСоединенияСБД), "SRVR=");
	Если ПозицияПоиска <> 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ПозицияТочкиСЗапятой = СтрНайти(СтрокаСоединенияСБД, ";");
	НачальнаяПозицияКопирования = 6 + 1;
	КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2; 
	
	ИмяСервера = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
	
	СтрокаСоединенияСБД = Сред(СтрокаСоединенияСБД, ПозицияТочкиСЗапятой + 1);
	
	// Позиция имени сервера
	ПозицияПоиска = СтрНайти(Врег(СтрокаСоединенияСБД), "REF=");
	Если ПозицияПоиска <> 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	НачальнаяПозицияКопирования = 6;
	ПозицияТочкиСЗапятой = СтрНайти(СтрокаСоединенияСБД, ";");
	КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2; 
	
	ИмяИБНаСервере = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
	ПутьКБД = ИмяСервера + "/ " + ИмяИБНаСервере;
	Возврат ПутьКБД;
	
КонецФункции

// Возвращает строку реквизитов объекта метаданных с заданным типом
//
// Параметры:
//  Ссылка – ЛюбаяСсылка – ссылка на элемент базы данных, для которого требуется получить результат функции
//  Тип    – Тип – тип значения реквизита
// 
//  Возвращаемое значение:
// Тип: Строка – строка реквизитов объекта метаданных конфигурации, разделенные символом ","
//
Функция ИменаРеквизитовПоТипу(Ссылка, Тип) Экспорт
	
	Результат = "";
	МетаданныеОбъекта = Ссылка.Метаданные();
	
	Для Каждого Реквизит Из МетаданныеОбъекта.Реквизиты Цикл
		Если Реквизит.Тип.СодержитТип(Тип) Тогда
			Результат = Результат + ?(ПустаяСтрока(Результат), "", ", ") + Реквизит.Имя;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Возвращает имя базового типа по переданному значению объекта метаданных
//
// Параметры:
//  ОбъектМетаданных - объект метаданных, по которому необходимо определить базовый тип
// 
// Возвращаемое значение:
//  Строка - имя базового типа по переданному значению объекта метаданных
//
Функция ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) Экспорт
	
	Если Метаданные.Документы.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаДокументы();
		
	ИначеЕсли Метаданные.Справочники.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаСправочники();
		
	ИначеЕсли Метаданные.Перечисления.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПеречисления();
		
	ИначеЕсли Метаданные.РегистрыСведений.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыСведений();
		
	ИначеЕсли Метаданные.РегистрыНакопления.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыНакопления();
		
	ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыБухгалтерии();
		
	ИначеЕсли Метаданные.РегистрыРасчета.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыРасчета();
		
	ИначеЕсли Метаданные.ПланыОбмена.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыОбмена();
		
	ИначеЕсли Метаданные.ПланыВидовХарактеристик.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыВидовХарактеристик();
		
	ИначеЕсли Метаданные.БизнесПроцессы.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаБизнесПроцессы();
		
	ИначеЕсли Метаданные.Задачи.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаЗадачи();
		
	ИначеЕсли Метаданные.ПланыСчетов.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыСчетов();
		
	ИначеЕсли Метаданные.ПланыВидовРасчета.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыВидовРасчета();
		
	ИначеЕсли Метаданные.Константы.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаКонстанты();
		
	ИначеЕсли Метаданные.ЖурналыДокументов.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаЖурналыДокументов();
		
	Иначе
		
		Возврат "";
		
	КонецЕсли;
	
КонецФункции

// Возвращает менеджер объекта по полному имени объекта метаданных
//
// Не обрабатываются точки маршрутов бизнес-процессов
//
// Параметры:
//  ПолноеИмя    - Строка, полное имя объекта метаданных,
//                 например, "Справочник.Организации"
//
// Возвращаемое значение:
//  СправочникМенеджер, ДокументМенеджер, ...
// 
Функция МенеджерОбъектаПоПолномуИмени(ПолноеИмя) Экспорт
	
	ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмя, ".");
	
	КлассОМ = ЧастиИмени[0];
	ИмяОМ   = ЧастиИмени[1];
	
	Если      ВРег(КлассОМ) = "ПЛАНОБМЕНА" Тогда
		Возврат ПланыОбмена[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "СПРАВОЧНИК" Тогда
		Возврат Справочники[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ДОКУМЕНТ" Тогда
		Возврат Документы[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ЖУРНАЛДОКУМЕНТОВ" Тогда
		Возврат ЖурналыДокументов[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЕРЕЧИСЛЕНИЕ" Тогда
		Возврат Перечисления[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ОТЧЕТ" Тогда
		Возврат Отчеты[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ОБРАБОТКА" Тогда
		Возврат Обработки[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВХАРАКТЕРИСТИК" Тогда
		Возврат ПланыВидовХарактеристик[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНСЧЕТОВ" Тогда
		Возврат ПланыСчетов[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВРАСЧЕТА" Тогда
		Возврат ПланЫВидовРасчета[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРСВЕДЕНИЙ" Тогда
		Возврат РегистрыСведений[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРНАКОПЛЕНИЯ" Тогда
		Возврат РегистрыНакопления[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРБУХГАЛТЕРИИ" Тогда
		Возврат РегистрыБухгалтерии[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРРАСЧЕТА" Тогда
		Возврат РегистрыРасчета[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "БИЗНЕСПРОЦЕСС" Тогда
		Возврат БизнесПроцессы[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ЗАДАЧА" Тогда
		Возврат Задачи[ИмяОМ];
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неизвестный тип объекта метаданных (%1)'"), КлассОМ);
	КонецЕсли;
	
КонецФункции

// Возвращает менеджер объекта по ссылке на объект
//
// Не обрабатываются точки маршрутов бизнес-процессов
//
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//
// Возвращаемое значение:
//  СправочникМенеджер, ДокументМенеджер, ...
// 
Функция МенеджерОбъектаПоСсылке(Ссылка) Экспорт
	
	ИмяОбъекта = Ссылка.Метаданные().Имя;
	ТипСсылки = ТипЗнч(Ссылка);
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Справочники[ИмяОбъекта];
		
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Документы[ИмяОбъекта];
		
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат БизнесПроцессы[ИмяОбъекта];
		
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыВидовХарактеристик[ИмяОбъекта];
		
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыСчетов[ИмяОбъекта];
		
	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыВидовРасчета[ИмяОбъекта];
		
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Задачи[ИмяОбъекта];
		
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыОбмена[ИмяОбъекта];
		
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Перечисления[ИмяОбъекта];
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

// Проверяет физическое наличие записи в информационной базе данных о переданном значении ссылки
//
// Параметры:
//  ЛюбаяСсылка - значение любой ссылки информационной базы данных
// 
// Возвращаемое значение:
//  Истина - ссылка физически существует;
//  Ложь   - ссылка физически не существует
//
Функция СсылкаСуществует(ЛюбаяСсылка) Экспорт
	
	ТекстЗапроса = "
	|ВЫБРАТЬ
	|	Ссылка КАК Ссылка
	|ИЗ
	|	[ИмяТаблицы]
	|ГДЕ
	|	Ссылка = &Ссылка
	|";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ИмяТаблицы]", ИмяТаблицыПоСсылке(ЛюбаяСсылка));
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Ссылка", ЛюбаяСсылка);
	
	УстановитьПривилегированныйРежим(Истина);
	
	Возврат НЕ Запрос.Выполнить().Пустой();
	
КонецФункции

// Функция ВидОбъектаПоСсылке возвращает имя вида объектов метаданных
// по ссылке на объект.
//
// Не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//
// Возвращаемое значение:
//  Строка       - имя вида объектов метаданных, например, "Справочник", "Документ" ...
// 
Функция ВидОбъектаПоСсылке(Ссылка) Экспорт
	
	Возврат ВидОбъектаПоТипу(ТипЗнч(Ссылка));
	
КонецФункции 

// Функция возвращает имя вида объектов метаданных по типу объекта.
//
// Не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  Тип       - Тип прикладного объекта, определенный в конфигурации
//
// Возвращаемое значение:
//  Строка       - имя вида объектов метаданных, например, "Справочник", "Документ" ...
// 
Функция ВидОбъектаПоТипу(Тип) Экспорт
	
	Если Справочники.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Справочник";
	
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Документ";
	
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "БизнесПроцесс";
	
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланВидовХарактеристик";
	
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланСчетов";
	
	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланВидовРасчета";
	
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Задача";
	
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланОбмена";
	
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Перечисление";
	
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неверный тип значения параметра (%1)'"), Строка(Тип));
	
	КонецЕсли;
	
КонецФункции 

// Возвращает полное имя объекта метаданных по переданному значению ссылки
// Например,
//  "Справочник.Номенклатура";
//  "Документ.ПриходнаяНакладная"
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - значение ссылки, для которого необходимо получить имя таблицы ИБ
// 
// Возвращаемое значение:
//  Строка - полное имя объекта метаданных для указанного значения ссылки
//
Функция ИмяТаблицыПоСсылке(Ссылка) Экспорт
	
	Возврат Ссылка.Метаданные().ПолноеИмя();
	
КонецФункции

// Проверить, что значение имеет ссылочный тип данных.
//
// Параметры:
//  Значение       - ссылка на объект, - элемент справочника, документ, ...
//
// Возвращаемое значение:
//  Булево       - Истина, если тип значения ссылочный.
//
Функция ЗначениеСсылочногоТипа(Значение) Экспорт
	
	Если Значение = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Документы.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Перечисления.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПланыСчетов.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если БизнесПроцессы.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Задачи.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПланыОбмена.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Проверка того, что тип имеет ссылочный тип данных
//
Функция ЭтоСсылка(Тип) Экспорт
	
	Возврат Справочники.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ Документы.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ Перечисления.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(Тип)
		ИЛИ Задачи.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип);
	
КонецФункции

// Проверяет является ли объект группой элементов.
//
// Параметры:
//  Объект       - Объект, Ссылка, ДанныеФормыСтруктура по типу Объект.
//
// Возвращаемое значение:
//  Булево.
//
Функция ОбъектЯвляетсяГруппой(Объект) Экспорт
	
	Если ЗначениеСсылочногоТипа(Объект) Тогда
		Ссылка = Объект;
	Иначе
		Ссылка = Объект.Ссылка;
	КонецЕсли;
	
	МетаданныеОбъекта = Ссылка.Метаданные();
	
	Если ЭтоСправочник(МетаданныеОбъекта) Тогда
		
		Если НЕ МетаданныеОбъекта.Иерархический
		 ИЛИ МетаданныеОбъекта.ВидИерархии
		     <> Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов Тогда
			
			Возврат Ложь;
		КонецЕсли;
		
	ИначеЕсли НЕ ЭтоПланВидовХарактеристик(МетаданныеОбъекта) Тогда
		Возврат Ложь;
		
	ИначеЕсли НЕ МетаданныеОбъекта.Иерархический Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Ссылка <> Объект Тогда
		Возврат Объект.ЭтоГруппа;
	КонецЕсли;
	
	Возврат ПолучитьЗначениеРеквизита(Ссылка, "ЭтоГруппа");
	
КонецФункции

// Возвращает ссылку, соответствующую объекту метаданных, для
// использования в базе данных.
//  Например:
//  Идентификатор = ОбщегоНазначения.ИнденификаторОбъектаМетаданных(ТипЗнч(Ссылка));
//  Идентификатор = ОбщегоНазначения.ИнденификаторОбъектаМетаданных(ОбъектМетаданных);
//  Идентификатор = ОбщегоНазначения.ИнденификаторОбъектаМетаданных("Справочник.Организации");
//
//  Поддерживаемые объекты метаданных:
// - Подсистемы (требуется программировать переименование)
// - Роли       (требуется программировать переименование)
// - ПланыОбмена
// - Справочники
// - Документы
// - ЖурналыДокументов
// - Отчеты
// - Обработки
// - ПланыВидовХарактеристик
// - ПланыСчетов
// - ПланыВидовРасчета
// - РегистрыСведений
// - РегистрыНакопления
// - РегистрыБухгалтерии
// - РегистрыРасчета
// - БизнесПроцессы
// - Задачи
// 
// Подробнее см. в функции СвойстваКоллекцийОбъектовМетаданных()
// модуля менеджера справочника ИдентификаторыОбъектовМетаданных.
//
// Параметры:
//  ОписаниеОбъектаМетаданных - ОбъектМетаданных
//                            - Тип, который можно успешно использовать
//                              в функции Метаданные.НайтиПоТипу()
//                            - Строка - полное имя объекта метаданных,
//                              которое можно успешно использовать
//                              в функции Метаданные.НайтиПоПолномуИмени()
// Возвращаемое значение:
//  СправочникСсылка.ИдентификаторыОбъектовМетаданных
//
Функция ИдентификаторОбъектаМетаданных(ОписаниеОбъектаМетаданных) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ТипОписанияОбъектаМетаданных = ТипЗнч(ОписаниеОбъектаМетаданных);
	Если ТипОписанияОбъектаМетаданных = Тип("Тип") Тогда
		
		ОбъектМетаданных = Метаданные.НайтиПоТипу(ОписаниеОбъектаМетаданных);
		Если ОбъектМетаданных = Неопределено Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка при выполнении функции ОбщегоНазначения.ИдентификаторОбъектаМетаданных().
				           |
				           |Объект метаданных не найден по типу:
				           |""%1"".'"),
				ОписаниеОбъектаМетаданных);
		Иначе
			Таблица = ОбъектМетаданных.ПолноеИмя();
		КонецЕсли;
		
	ИначеЕсли ТипОписанияОбъектаМетаданных = Тип("Строка") Тогда
		Таблица = ОписаниеОбъектаМетаданных;
	Иначе
		Таблица = ОписаниеОбъектаМетаданных.ПолноеИмя();
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ПолноеИмя", Таблица);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Идентификаторы.Ссылка КАК Ссылка,
	|	Идентификаторы.КлючОбъектаМетаданных,
	|	Идентификаторы.ПолноеИмя
	|ИЗ
	|	Справочник.ИдентификаторыОбъектовМетаданных КАК Идентификаторы
	|ГДЕ
	|	Идентификаторы.ПолноеИмя = &ПолноеИмя
	|	И НЕ Идентификаторы.ПометкаУдаления";
	
	Выгрузка = Запрос.Выполнить().Выгрузить();
	Если Выгрузка.Количество() = 0 Тогда
		// Если идентификатор не найден по полному имени, возможно что полное имя задано с ошибкой
		Если ТипОписанияОбъектаМетаданных = Тип("Строка")
		   И Метаданные.НайтиПоПолномуИмени(ОписаниеОбъектаМетаданных) = Неопределено Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка при выполнении функции ОбщегоНазначения.ИдентификаторОбъектаМетаданных().
				           |
				           |Объект метаданнных не найден по полному имени:
				           |""%1"".'"),
				ОписаниеОбъектаМетаданных);
		КонецЕсли;
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Ошибка при выполнении функции ОбщегоНазначения.ИдентификаторОбъектаМетаданных().
			           |
			           |Для объекта метаданных ""%1""
			           |не найден идентификатор
			           |в справочнике ""Идентификаторы объектов метаданных"".
			           |
			           |Если справочник не был обновлен при обновлении информационной базы,
			           |следует выполнить обновление вручную:
			           |""Все функции"" -> ""Справочник. Идентификаторы объектов метаданных"" ->
			           |команда формы списка ""Обновить данные справочника"".'"),
			Таблица);
	ИначеЕсли Выгрузка.Количество() > 1 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Ошибка при выполнении функции ОбщегоНазначения.ИдентификаторОбъектаМетаданных().
			           |
			           |Для объекта метаданных ""%1""
			           |найдено несколько идентификаторов
			           |в справочнике ""Идентификаторы объектов метаданных"".
			           |
			           |Данные справочника некорректны. Если справочник не был обновлен
			           |при обновлении информационной базы, следует выполнить обновление вручную:
			           |""Все функции"" -> ""Справочник. Идентификаторы объектов метаданных"" ->
			           |команда формы списка ""Обновить данные справочника"".'"),
			Таблица);
	КонецЕсли;
	
	// Проверка соответствия ключа объекта метаданных полному имени объекта метаданных
	РезультатПроверки = Справочники.ИдентификаторыОбъектовМетаданных.КлючОбъектаМетаданныхСоответствуетПолномуИмени(Выгрузка[0]);
	Если РезультатПроверки.НеСоответствует Тогда
		Если РезультатПроверки.ОбъектМетаданных = Неопределено Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка при выполнении функции ОбщегоНазначения.ИдентификаторОбъектаМетаданных().
				           |
				           |Для объекта метаданных ""%1""
				           |найден идентификатор в справочнике ""Идентификаторы объектов метаданных"",
				           |которому соответствует удаленный объект метаданных.
				           |
				           |Данные справочника некорректны. Если справочник не был обновлен
				           |при обновлении информационной базы, следует выполнить обновление вручную:
				           |""Все функции"" -> ""Справочник. Идентификаторы объектов метаданных"" ->
				           |команда формы списка ""Обновить данные справочника"".'"),
				Таблица);
		Иначе
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка при выполнении функции ОбщегоНазначения.ИдентификаторОбъектаМетаданных().
				           |
				           |Для объекта метаданных ""%1""
				           |найден идентификатор в справочнике ""Идентификаторы объектов метаданных"",
				           |который соответствует другому объекту метаданных ""%2"".
				           |
				           |Данные справочника некорректны. Если справочник не был обновлен
				           |при обновлении информационной базы, следует выполнить обновление вручную:
				           |""Все функции"" -> ""Справочник. Идентификаторы объектов метаданных"" ->
				           |команда формы списка ""Обновить данные справочника"".'"),
				Таблица,
				РезультатПроверки.ОбъектМетаданных);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Выгрузка[0].Ссылка;
	
КонецФункции

// Возвращает объект метаданных, по переданному идентификатору
//
// Параметры:
//  Идентификатор - СправочникСсылка.ИдентификаторыОбъектовМетаданных
//
// Возвращаемое значение:
//  ОбъектМетаданных
//
Функция ОбъектМетаданныхПоИдентификатору(Идентификатор) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", Идентификатор);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Идентификаторы.Ссылка КАК Ссылка,
	|	Идентификаторы.КлючОбъектаМетаданных,
	|	Идентификаторы.ПолноеИмя,
	|	Идентификаторы.ПометкаУдаления
	|ИЗ
	|	Справочник.ИдентификаторыОбъектовМетаданных КАК Идентификаторы
	|ГДЕ
	|	Идентификаторы.Ссылка = &Ссылка";
	
	Выгрузка = Запрос.Выполнить().Выгрузить();
	
	Если Выгрузка.Количество() = 0 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Ошибка при выполнении функции ОбщегоНазначения.ОбъектМетаданныхПоИдентификатору().
			           |
			           |Идентификатор ""%1""
			           |не найден в справочнике ""Идентификаторы объектов метаданных"".
			           |
			           |Если справочник не был обновлен при обновлении информационной базы,
			           |следует выполнить обновление вручную:
			           |""Все функции"" -> ""Справочник. Идентификаторы объектов метаданных"" ->
			           |команда формы списка ""Обновить данные справочника"".'"),
			Строка(Идентификатор));
	КонецЕсли;
	
	// Проверка соответствия ключа объекта метаданных полному имени объекта метаданных
	РезультатПроверки = Справочники.ИдентификаторыОбъектовМетаданных.КлючОбъектаМетаданныхСоответствуетПолномуИмени(Выгрузка[0]);
	Если РезультатПроверки.НеСоответствует Тогда
		Если РезультатПроверки.ОбъектМетаданных = Неопределено Тогда
			Если РезультатПроверки.КлючОбъектаМетаданных = Неопределено Тогда
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Ошибка при выполнении функции ОбщегоНазначения.ОбъектМетаданныхПоИдентификатору().
					           |
					           |Идентификатору ""%1""
					           |найденому в справочнике ""Идентификаторы объектов метаданных"",
					           |соответствует несуществующий объект метаданных
					           |""%2"".
					           |
					           |Если справочник не был обновлен при обновлении информационной базы,
					           |следует выполнить обновление вручную:
					           |""Все функции"" -> ""Справочник. Идентификаторы объектов метаданных"" ->
					           |команда формы списка ""Обновить данные справочника"".'"),
					Строка(Идентификатор),
					Выгрузка[0].ПолноеИмя);
			Иначе
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Ошибка при выполнении функции ОбщегоНазначения.ОбъектМетаданныхПоИдентификатору().
					           |
					           |Идентификатору ""%1""
					           |найденому в справочнике ""Идентификаторы объектов метаданных"",
					           |соответствует удаленный объект метаданных.
					           |
					           |Данные справочника некорректны. Если справочник не был обновлен
					           |при обновлении информационной базы, следует выполнить обновление вручную:
					           |""Все функции"" -> ""Справочник. Идентификаторы объектов метаданных"" ->
					           |команда формы списка ""Обновить данные справочника"".'"),
					Строка(Идентификатор));
			КонецЕсли;
		Иначе
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка при выполнении функции ОбщегоНазначения.ИдентификаторОбъектаМетаданных().
				           |
				           |Идентификатору ""%1""
				           |найденому в справочнике ""Идентификаторы объектов метаданных"",
				           |соответствует объект метаданных ""%2"",
				           |полное имя которого отличается от заданного в идентификаторе.
				           |
				           |Если справочник не был обновлен при обновлении информационной базы,
				           |следует выполнить обновление вручную:
				           |""Все функции"" -> ""Справочник. Идентификаторы объектов метаданных"" ->
				           |команда формы списка ""Обновить данные справочника"".'"),
				Строка(Идентификатор),
				РезультатПроверки.ОбъектМетаданных.ПолноеИмя());
		КонецЕсли;
	КонецЕсли;
	
	Если Выгрузка[0].ПометкаУдаления Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Ошибка при выполнении функции ОбщегоНазначения.ОбъектМетаданныхПоИдентификатору().
			           |
			           |Идентификатор ""%1""
			           |найден в справочнике ""Идентификаторы объектов метаданных"",
			           |но значение реквизита ""Пометка удаления"" установлено Истина.
			           |
			           |Если справочник не был обновлен при обновлении информационной базы,
			           |следует выполнить обновление вручную:
			           |""Все функции"" -> ""Справочник. Идентификаторы объектов метаданных"" ->
			           |команда формы списка ""Обновить данные справочника"".'"),
			Строка(Идентификатор));
	КонецЕсли;
	
	Возврат РезультатПроверки.ОбъектМетаданных;
	
КонецФункции

// Только для использования в процедуре ОбщегоНазначенияПереопределяемый.Заполнить-
// ТаблицуПереименованияОбъектовМетаданных() для описания переименований объектов метаданных.
// 
// Параметры:
//   Итог                    - передается в процедуру подсистемой БазоваяФункциональность.
//   ВерсияИБ                - Строка - версия при переходе на которую нужно выполнить переименование.
//   СтароеПолноеИмя         - Строка - старое полное имя объекта метаданных,    которое нужно переименовать.
//   НовоеПолноеИмя          - Строка - новое  полное имя объекта метаданных, на которое нужно переименовать.
//   ИдентификаторБиблиотеки - Строка - внутренний идентификатор библиотеки, к которой относится ВерсияИБ,
//                             для основной конфигурации не требуется.
// 
Процедура ДобавитьПереименование(Итог, ВерсияИБ, СтароеПолноеИмя, НовоеПолноеИмя, ИдентификаторБиблиотеки = "") Экспорт
	
	СтароеИмяКоллекции = ВРег(ИмяКоллекции(СтароеПолноеИмя));
	НовоеИмяКоллекции  = ВРег(ИмяКоллекции(НовоеПолноеИмя));
	
	Если СтароеИмяКоллекции <> НовоеИмяКоллекции Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Ошибка в процедуре ОбщегоНазначенияПереопределяемый.Заполнить-
			           |ТаблицуПереименованияОбъектовМетаданных().
			           |
			           |Не совпадают имена типов старого объекта метаданных:
			           |""%1""
			           |и нового объекта метаданных:
			           |""%2"".'"),
			СтароеПолноеИмя,
			НовоеПолноеИмя);
	КонецЕсли;
	
	Если Итог.КоллекцииБезКлюча[СтароеИмяКоллекции] = Неопределено Тогда
		
		СписокДопустимыхТипов = "";
		Для каждого КлючИЗначение Из Итог.КоллекцииБезКлюча Цикл
			СписокДопустимыхТипов = СписокДопустимыхТипов + КлючИЗначение.Значение + "," + Символы.ПС;
		КонецЦикла;
		СписокДопустимыхТипов = СокрП(СписокДопустимыхТипов);
		СписокДопустимыхТипов = ?(ЗначениеЗаполнено(СписокДопустимыхТипов),
			Лев(СписокДопустимыхТипов, СтрДлина(СписокДопустимыхТипов) - 1), "");
		
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Ошибка в процедуре ОбщегоНазначенияПереопределяемый.Заполнить-
			           |ТаблицуПереименованияОбъектовМетаданных().
			           |
			           |Объект метаданных ""%1"" и остальные
			           |объекты метаданных этого типа обновляются автоматически.
			           |
			           |Переименование требуется только для следующих типов:
			           |%2.'"),
			СтароеПолноеИмя,
			НовоеПолноеИмя,
			СписокДопустимыхТипов);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ИдентификаторБиблиотеки) Тогда
		Библиотека = ВРег(ИдентификаторБиблиотеки) <> ВРег(Метаданные.Имя);
	Иначе
		ИдентификаторБиблиотеки = Метаданные.Имя;
		Библиотека = Ложь;
	КонецЕсли;
	
	ПорядокБиблиотеки = Итог.ПорядокБиблиотек[ИдентификаторБиблиотеки];
	Если ПорядокБиблиотеки = Неопределено Тогда
		ПорядокБиблиотеки = Итог.ПорядокБиблиотек.Количество();
		Итог.ПорядокБиблиотек.Вставить(ИдентификаторБиблиотеки, ПорядокБиблиотеки);
	КонецЕсли;
	
	ВерсияБиблиотеки = Итог.ВерсииБиблиотек[ИдентификаторБиблиотеки];
	Если ВерсияБиблиотеки = Неопределено Тогда
		ВерсияБиблиотеки = ОбновлениеИнформационнойБазы.ВерсияИБ(ИдентификаторБиблиотеки);
		Итог.ВерсииБиблиотек.Вставить(ИдентификаторБиблиотеки, ВерсияБиблиотеки);
	КонецЕсли;
	
	Если ВерсияБиблиотеки = "0.0.0.0" Тогда
		// При начальном заполнении переименования не требуются.
		Возврат;
	КонецЕсли;
	
	Попытка
		Результат = ОбщегоНазначенияКлиентСервер.СравнитьВерсии(ВерсияИБ, ВерсияБиблиотеки);
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Если Библиотека Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка в процедуре ОбщегоНазначенияПереопределяемый.Заполнить-
				           |ТаблицуПереименованияОбъектовМетаданных().
				           |
				           |При сравнении укзанной версии ""%1""
				           |с текущей версией ""%2""
				           |указанной библиотеки ""%3""
				           |произошла ошибка:
				           |""%4"".'"),
				ВерсияИБ,
				ВерсияБиблиотеки,
				ИдентификаторБиблиотеки,
				КраткоеПредставлениеОшибки(ИнформацияОбОшибке));
		Иначе
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка в процедуре ОбщегоНазначенияПереопределяемый.Заполнить-
				           |ТаблицуПереименованияОбъектовМетаданных().
				           |
				           |При сравнении укзанной версии ""%1""
				           |с текущей версией конфигурации ""%2""
				           |произошла ошибка:
				           |""%3"".'"),
				ВерсияИБ,
				ВерсияБиблиотеки,
				КраткоеПредставлениеОшибки(ИнформацияОбОшибке));
		КонецЕсли;
	КонецПопытки;
	
	Если Результат > 0 Тогда
		ЧастиВерсии = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ВерсияИБ, ".");
		
		ОписаниеПереименования = Итог.Таблица.Добавить();
		ОписаниеПереименования.ПорядокБиблиотеки = ПорядокБиблиотеки;
		ОписаниеПереименования.ВерсияЧасть1      = Число(ЧастиВерсии[0]);
		ОписаниеПереименования.ВерсияЧасть2      = Число(ЧастиВерсии[1]);
		ОписаниеПереименования.ВерсияЧасть3      = Число(ЧастиВерсии[2]);
		ОписаниеПереименования.ВерсияЧасть4      = Число(ЧастиВерсии[3]);
		ОписаниеПереименования.СтароеПолноеИмя   = СтароеПолноеИмя;
		ОписаниеПереименования.НовоеПолноеИмя    = НовоеПолноеИмя;
		ОписаниеПереименования.ПорядокДобавления = Итог.Таблица.Индекс(ОписаниеПереименования);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает строковое представление типа. 
// Для ссылочных типов возвращает в формате "СправочникСсылка.ИмяОбъекта" или "ДокументСсылка.ИмяОбъекта"
// Для остальных типов приводит тип к строке, например "Число".
//
Функция СтроковоеПредставлениеТипа(Тип) Экспорт
	
	Представление = "";
	
	Если ЭтоСсылка(Тип) Тогда
	
		ПолноеИмя = Метаданные.НайтиПоТипу(Тип).ПолноеИмя();
		ИмяОбъекта = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмя, ".")[1];
		
		Если Справочники.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "СправочникСсылка";
		
		ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ДокументСсылка";
		
		ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "БизнесПроцессСсылка";
		
		ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланВидовХарактеристикСсылка";
		
		ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланСчетовСсылка";
		
		ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланВидовРасчетаСсылка";
		
		ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ЗадачаСсылка";
		
		ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланОбменаСсылка";
		
		ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПеречислениеСсылка";
		
		КонецЕсли;
		
		Результат = ?(Представление = "", Представление, Представление + "." + ИмяОбъекта);
		
	Иначе
		
		Результат = Строка(Тип);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Проверить, что описание типа состоит из единственного типа значения и 
// совпадает с нужным типом.
//
// Возвращаемое значение:
//   Булево      - Совпадает или нет
//
Функция ОписаниеТипаСостоитИзТипа(ОписаниеТипа, ТипЗначения) Экспорт
	
	Если ОписаниеТипа.Типы().Количество() = 1
	   И ОписаниеТипа.Типы().Получить(0) = ТипЗначения Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;

КонецФункции

// Проверяет наличие табличной части у справочника
//
//Параметры
//  ИмяСправочника    - Строка - имя справочника, для которого осуществляется проверка.
//  ИмяТабличнойЧасти - Строка - имя табличной части, наличие которой проверяется.
//
//Возвращаемое значение:
//  Булево   - Истина, если табличная часть есть, ложь в обратном случае
//
//Пример:
//  Если НЕ ОбщегоНазначения.НаличиеТабличнойЧастиУСправочника(ИмяСправочника,"КонтактнаяИнформация") Тогда
//  	Возврат;
//  КонецЕсли;
//
Функция НаличиеТабличнойЧастиУСправочника(ИмяСправочника, ИмяТабличнойЧасти) Экспорт
	
	Возврат (Метаданные.Справочники[ИмяСправочника].ТабличныеЧасти.Найти(ИмяТабличнойЧасти) <> Неопределено);
	
КонецФункции 

// Формирует расширенное представление объекта.
// Расширенное представление объекта складывается из представления объекта, кода и наименования.
// Если для объекта не удалось получить расширенное представление,
// то возвращается стандартное представление объекта, формируемое платформой.
//
// Пример возвращаемого значения функции:
// "Контрагент 0А-0001234, ООО Телекоммуникационные системы"
//
//  Параметры:
// Объект. Тип: СправочникСсылка,
//				ПланСчетовСсылка,
//				ПланОбменаСсылка,
//				ПланВидовХарактеристикСсылка,
//				ПланВидовРасчетаСсылка.
// Объект, для которого требуется получить расширенное представление.
//
//  Возвращаемое значение:
// Тип. Строка.
// Расширенное представление объекта.
//
Функция РасширенноеПредставлениеОбъекта(Объект) Экспорт
	
	ОбъектМетаданных = Объект.Метаданные();
	
	ИмяБазовогоТипа = ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных);
	
	Если    ИмяБазовогоТипа = ИмяТипаСправочники()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыСчетов()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыОбмена()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовХарактеристик()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовРасчета()
		Тогда
		
		Если  ЭтоСтандартныйРеквизит(ОбъектМетаданных.СтандартныеРеквизиты, "Код")
			И ЭтоСтандартныйРеквизит(ОбъектМетаданных.СтандартныеРеквизиты, "Наименование") Тогда
			
			ЗначенияРеквизитов = ПолучитьЗначенияРеквизитов(Объект, "Код, Наименование");
			
			ПредставлениеОбъекта = ?(ПустаяСтрока(ОбъектМетаданных.ПредставлениеОбъекта), 
										?(ПустаяСтрока(ОбъектМетаданных.Синоним), ОбъектМетаданных.Имя, ОбъектМетаданных.Синоним
										),
									ОбъектМетаданных.ПредставлениеОбъекта
			);
			
			Результат = "[ПредставлениеОбъекта] [Код], [Наименование]";
			Результат = СтрЗаменить(Результат, "[ПредставлениеОбъекта]", ПредставлениеОбъекта);
			Результат = СтрЗаменить(Результат, "[Код]",          ?(ПустаяСтрока(ЗначенияРеквизитов.Код), "<>", ЗначенияРеквизитов.Код));
			Результат = СтрЗаменить(Результат, "[Наименование]", ?(ПустаяСтрока(ЗначенияРеквизитов.Наименование), "<>", ЗначенияРеквизитов.Наименование));
			
		Иначе
			
			Результат = Строка(Объект);
			
		КонецЕсли;
		
	Иначе
		
		Результат = Строка(Объект);
		
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

// Возвращает признак того, что реквизит входит в подмножество стандартных реквизитов
//
// Параметры:
//  СтандартныеРеквизиты – ОписанияСтандартныхРеквизитов - тип и значение описывает коллекцию настроек различных стандартных реквизитов;
//  ИмяРеквизита – Строка – реквизит который необходимо проверить на принадлежность множеству стандартных реквизитов;
// 
//  Возвращаемое значение:
// Тип: Булево. Истина -  реквизит входит в подмножество стандартных реквизитов; Ложь – нет.
//
Функция ЭтоСтандартныйРеквизит(СтандартныеРеквизиты, ИмяРеквизита) Экспорт
	
	Для Каждого Реквизит ИЗ СтандартныеРеквизиты Цикл
		Если Реквизит.Имя = ИмяРеквизита Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
	
КонецФункции

// Получает таблицу значений с описанием требуемых свойств всех реквизитов объекта метаданного
// Получает значения свойств стандартных реквизитов и пользовательских реквизитов (созданных в режиме конфигуратора)
//
// Параметры:
//  ОбъектМетаданных  - Объект метаданных конфигурации, для которого необходимо получить значение свойств реквизитов.
//                      Например: Метаданные.Документ.РеализацияТоваровИУслуг
//  Свойства - Строка - свойства реквизитов, перечисленных через запятую, значение которых необходимо получить.
//                      Например: "Имя, Тип, Синоним, Подсказка"
//
// Возвращаемое значение:
//  ТаблицаЗначений - таблица значений с описанием требуемых свойств всех реквизитов объекта метаданного
//
Функция ПолучитьТаблицуОписанияСвойствОбъекта(ОбъектМетаданных, Свойства) Экспорт
	
	МассивСвойств = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Свойства);
	
	// возвращаемое значение функции
	ТаблицаОписанияСвойствОбъекта = Новый ТаблицаЗначений;
	
	// добавляем в таблицу поля согласно именам переданных свойств
	Для Каждого ИмяСвойства ИЗ МассивСвойств Цикл
		ТаблицаОписанияСвойствОбъекта.Колонки.Добавить(СокрЛП(ИмяСвойства));
	КонецЦикла;
	
	// заполняем строку таблицы свойствами реквизитов объекта метаданных
	Для Каждого Реквизит ИЗ ОбъектМетаданных.Реквизиты Цикл
		ЗаполнитьЗначенияСвойств(ТаблицаОписанияСвойствОбъекта.Добавить(), Реквизит);
	КонецЦикла;
	
	// заполняем строку таблицы свойствами стандартных реквизитов объекта метаданных
	Для Каждого Реквизит ИЗ ОбъектМетаданных.СтандартныеРеквизиты Цикл
		ЗаполнитьЗначенияСвойств(ТаблицаОписанияСвойствОбъекта.Добавить(), Реквизит);
	КонецЦикла;
	
	Возврат ТаблицаОписанияСвойствОбъекта;
	
КонецФункции

// Возвращает состояние использования элемента состава общего реквизита
//
// Параметры:
//  ЭлементСостава - ОбъектМетаданных - элемент состава общего реквизита использование
//   которого требуется проверить
//  МетаданныеОбщегоРеквизита - ОбъектМетаданных - метаданные общего реквизита,  
//   которому принадлежит ЭлементСостава
//
// Возвращаемое значение:
//  Булево - Истина, если элемент состава используется, иначе Ложь
//
Функция ЭлементСоставаОбщегоРеквизитаИспользуется(Знач ЭлементСостава, Знач МетаданныеОбщегоРеквизита) Экспорт
	
	Если ЭлементСостава.Использование = Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита.Использовать Тогда
		Возврат Истина;
	ИначеЕсли ЭлементСостава.Использование = Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита.НеИспользовать Тогда
		Возврат Ложь;
	Иначе
		Возврат МетаданныеОбщегоРеквизита.АвтоИспользование = Метаданные.СвойстваОбъектов.АвтоИспользованиеОбщегоРеквизита.Использовать;
	КонецЕсли;
	
КонецФункции

// Возвращает признак того, что объект метаданных используется в общих реквизитах-разделителях.
//
// Параметры:
// ОбъектМетаданных - Строка; ОбъектМетаданных - Если объект метаданных задан строкой, происходит обращение к модулю повторного использования.
//
// Возвращаемое значение:
// Булево - Истина, если объект метаданных используется хотя бы в одном общем разделителе.
//
Функция ЭтоРазделенныйОбъектМетаданных(Знач ОбъектМетаданных) Экспорт
	
	Если ТипЗнч(ОбъектМетаданных) = Тип("Строка") Тогда
		ПолноеИмяОбъектаМетаданных = ОбъектМетаданных;
	Иначе
		ПолноеИмяОбъектаМетаданных = ОбъектМетаданных.ПолноеИмя();
	КонецЕсли;
	
	РазделенныеОбъектыМетаданных = ОбщегоНазначенияПовтИсп.РазделенныеОбъектыМетаданных();
	Возврат РазделенныеОбъектыМетаданных.Получить(ПолноеИмяОбъектаМетаданных) <> Неопределено;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции определения типов объектов метаданных

// Ссылочные типы данных

// Определяет принадлежность объекта метаданных к общему типу "Документ"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоДокумент(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаДокументы();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Справочник"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоСправочник(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаСправочники();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Перечисление"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПеречисление(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПеречисления();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План обмена"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПланОбмена(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПланыОбмена();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План видов характеристик"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПланВидовХарактеристик(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПланыВидовХарактеристик();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Бизнес-процесс"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоБизнесПроцесс(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаБизнесПроцессы();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Задача"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоЗадача(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаЗадачи();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План счетов"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПланСчетов(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПланыСчетов();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План видов расчета"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПланВидовРасчета(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПланыВидовРасчета();
	
КонецФункции

// Регистры

// Определяет принадлежность объекта метаданных к общему типу "Регистр сведений"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоРегистрСведений(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегистрыСведений();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр накопления"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоРегистрНакопления(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегистрыНакопления();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр бухгалтерии"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоРегистрБухгалтерии(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегистрыБухгалтерии();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр расчета"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоРегистрРасчета(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегистрыРасчета();
	
КонецФункции

// Константы

// Определяет принадлежность объекта метаданных к общему типу "Константа"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоКонстанта(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаКонстанты();
	
КонецФункции

// Журналы документов

// Определяет принадлежность объекта метаданных к общему типу "Журнал документов"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоЖурналДокументов(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаЖурналыДокументов();
	
КонецФункции

// Общие

// Определяет принадлежность объекта метаданных к типу регистр
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоРегистр(ОбъектМетаданных) Экспорт
	
	ИмяБазовогоТипа = ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных);
	
	Возврат ИмяБазовогоТипа = ИмяТипаРегистрыСведений()
		ИЛИ ИмяБазовогоТипа = ИмяТипаРегистрыНакопления()
		ИЛИ ИмяБазовогоТипа = ИмяТипаРегистрыБухгалтерии()
		ИЛИ ИмяБазовогоТипа = ИмяТипаРегистрыРасчета();
	
КонецФункции

// Определяет принадлежность объекта метаданных к ссылочному типу
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоОбъектСсылочногоТипа(ОбъектМетаданных) Экспорт
	
	ИмяБазовогоТипа = ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных);
	
	Возврат ИмяБазовогоТипа = ИмяТипаСправочники()
		ИЛИ ИмяБазовогоТипа = ИмяТипаДокументы()
		ИЛИ ИмяБазовогоТипа = ИмяТипаБизнесПроцессы()
		ИЛИ ИмяБазовогоТипа = ИмяТипаЗадачи()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыСчетов()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыОбмена()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовХарактеристик()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовРасчета();
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Имена типов.

// Возвращает значение для идентификации общего типа "Регистры сведений"
//
// Тип: Строка
//
Функция ИмяТипаРегистрыСведений() Экспорт
	
	Возврат "РегистрыСведений";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Регистры накопления"
//
// Тип: Строка
//
Функция ИмяТипаРегистрыНакопления() Экспорт
	
	Возврат "РегистрыНакопления";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Регистры бухгалтерии"
//
// Тип: Строка
//
Функция ИмяТипаРегистрыБухгалтерии() Экспорт
	
	Возврат "РегистрыБухгалтерии";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Регистры расчета"
//
// Тип: Строка
//
Функция ИмяТипаРегистрыРасчета() Экспорт
	
	Возврат "РегистрыРасчета";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Документы"
//
// Тип: Строка
//
Функция ИмяТипаДокументы() Экспорт
	
	Возврат "Документы";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Справочники"
//
// Тип: Строка
//
Функция ИмяТипаСправочники() Экспорт
	
	Возврат "Справочники";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Перечисления"
//
// Тип: Строка
//
Функция ИмяТипаПеречисления() Экспорт
	
	Возврат "Перечисления";
	
КонецФункции

// Функция-свойство: возвращает значение для идентификации общего типа "Отчеты"
//
// Тип: Строка
//
Функция ИмяТипаОтчеты() Экспорт
	
	Возврат "Отчеты";
	
КонецФункции

// Функция-свойство: возвращает значение для идентификации общего типа "Обработки"
//
// Тип: Строка
//
Функция ИмяТипаОбработки() Экспорт
	
	Возврат "Обработки";
	
КонецФункции

// Возвращает значение для идентификации общего типа "ПланыОбмена"
//
// Тип: Строка
//
Функция ИмяТипаПланыОбмена() Экспорт
	
	Возврат "ПланыОбмена";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Планы видов характеристик"
//
// Тип: Строка
//
Функция ИмяТипаПланыВидовХарактеристик() Экспорт
	
	Возврат "ПланыВидовХарактеристик";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Бизнес-процессы"
//
// Тип: Строка
//
Функция ИмяТипаБизнесПроцессы() Экспорт
	
	Возврат "БизнесПроцессы";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Задачи"
//
// Тип: Строка
//
Функция ИмяТипаЗадачи() Экспорт
	
	Возврат "Задачи";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Планы счетов"
//
// Тип: Строка
//
Функция ИмяТипаПланыСчетов() Экспорт
	
	Возврат "ПланыСчетов";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Планы видов расчета"
//
// Тип: Строка
//
Функция ИмяТипаПланыВидовРасчета() Экспорт
	
	Возврат "ПланыВидовРасчета";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Константы"
//
// Тип: Строка
//
Функция ИмяТипаКонстанты() Экспорт
	
	Возврат "Константы";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Журналы документов"
//
// Тип: Строка
//
Функция ИмяТипаЖурналыДокументов() Экспорт
	
	Возврат "ЖурналыДокументов";
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Сохранение, чтение и удаление настроек из хранилищ

// Сохраняет настройку в хранилище общих настроек.
// 
// Параметры:
//   Соответствуют методу ХранилищеОбщихНастроекСохранить.Сохранить, 
//   подробнее - см. параметры процедуры ХранилищеСохранить()
// 
Процедура ХранилищеОбщихНастроекСохранить(КлючОбъекта, КлючНастроек = "", Значение,
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	ХранилищеСохранить(
		ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		Значение,
		ОписаниеНастроек,
		ИмяПользователя,
		НужноОбновитьПовторноИспользуемыеЗначения
	);
	
КонецПроцедуры

// Загружает настройку из хранилища общих настроек.
//
// Параметры:
//   Соответствуют методу ХранилищеОбщихНастроек.Загрузить,
//   подробнее - см. параметры функции ХранилищеЗагрузить()
//
Функция ХранилищеОбщихНастроекЗагрузить(КлючОбъекта, КлючНастроек = "", ЗначениеПоУмолчанию = Неопределено, 
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	
	Возврат ХранилищеЗагрузить(
		ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		ЗначениеПоУмолчанию,
		ОписаниеНастроек,
		ИмяПользователя
	);
	
КонецФункции

// Удаляет настройку из хранилища общих настроек.
//
// Параметры:
//   Соответствуют методу ХранилищеОбщихНастроек.Удалить,
//   подробнее - см. параметры функции ХранилищеУдалить()
//
Процедура ХранилищеОбщихНастроекУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	
	ХранилищеУдалить(
		ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		ИмяПользователя
	);
	
КонецПроцедуры

// Сохраняет массив пользовательских настроек МассивСтруктур. 
// Может применяться для случаев вызова с клиента.
// 
// Параметры:
//    МассивСтруктур - Массив - массив структур с полями "Объект", "Настройка", "Значение".
//    НужноОбновитьПовторноИспользуемыеЗначения - Булево - требуется обновить повторно используемые значения
//
Процедура ХранилищеОбщихНастроекСохранитьМассив(МассивСтруктур,
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	Если Не ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого Элемент Из МассивСтруктур Цикл
		ХранилищеОбщихНастроек.Сохранить(Элемент.Объект, Элемент.Настройка, Элемент.Значение);
	КонецЦикла;
	
	Если НужноОбновитьПовторноИспользуемыеЗначения Тогда
		ОбновитьПовторноИспользуемыеЗначения();
	КонецЕсли;
	
КонецПроцедуры

// Сохраняет массив пользовательских настроек МассивСтруктур и обновляет повторно
//   используемые значения. Может применяться для случаев вызова с клиента.
// 
// Параметры:
//    МассивСтруктур - Массив - массив структур с полями "Объект", "Настройка", "Значение".
//
Процедура ХранилищеОбщихНастроекСохранитьМассивИОбновитьПовторноИспользуемыеЗначения(МассивСтруктур) Экспорт
	
	ХранилищеОбщихНастроекСохранитьМассив(МассивСтруктур, Истина);
	
КонецПроцедуры

// Сохраняет настройку в хранилище общих настроек и обновляет повторно используемые 
//   значения.
// 
// Параметры:
//   Соответствуют методу ХранилищеОбщихНастроекСохранить.Сохранить, 
//   подробнее - см. параметры процедуры ХранилищеСохранить()
//
Процедура ХранилищеОбщихНастроекСохранитьИОбновитьПовторноИспользуемыеЗначения(КлючОбъекта, КлючНастроек, Значение) Экспорт
	
	ХранилищеОбщихНастроекСохранить(КлючОбъекта, КлючНастроек, Значение,,,Истина);
	
КонецПроцедуры

// Сохраняет настройку в хранилище системных настроек.
// 
// Параметры:
//   Соответствуют методу ХранилищеСистемныхНастроек.Сохранить, 
//   подробнее - см. параметры процедуры ХранилищеСохранить()
// 
Процедура ХранилищеСистемныхНастроекСохранить(КлючОбъекта, КлючНастроек = "", Значение,
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	ХранилищеСохранить(
		ХранилищеСистемныхНастроек, 
		КлючОбъекта, 
		КлючНастроек, 
		Значение,
		ОписаниеНастроек, 
		ИмяПользователя, 
		НужноОбновитьПовторноИспользуемыеЗначения
	);
	
КонецПроцедуры

// Загружает настройку из хранилища системных настроек.
//
// Параметры:
//   Соответствуют методу ХранилищеСистемныхНастроек.Загрузить,
//   подробнее - см. параметры функции ХранилищеЗагрузить()
//
Функция ХранилищеСистемныхНастроекЗагрузить(КлючОбъекта, КлючНастроек = "", ЗначениеПоУмолчанию = Неопределено, 
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	
	Возврат ХранилищеЗагрузить(
		ХранилищеСистемныхНастроек, 
		КлючОбъекта, 
		КлючНастроек, 
		ЗначениеПоУмолчанию, 
		ОписаниеНастроек, 
		ИмяПользователя
	);
	
КонецФункции

// Удаляет настройку из хранилища системных настроек.
//
// Параметры:
//   Соответствуют методу ХранилищеСистемныхНастроек.Удалить,
//   подробнее - см. параметры функции ХранилищеУдалить()
//
Процедура ХранилищеСистемныхНастроекУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	
	ХранилищеУдалить(
		ХранилищеСистемныхНастроек,
		КлючОбъекта,
		КлючНастроек,
		ИмяПользователя
	);
	
КонецПроцедуры

// Сохраняет настройку в хранилище настроек данных форм.
// 
// Параметры:
//   Соответствуют методу ХранилищеСистемныхНастроек.Сохранить, 
//   подробнее - см. параметры процедуры ХранилищеСохранить()
//
Процедура ХранилищеНастроекДанныхФормСохранить(КлючОбъекта, КлючНастроек = "", Значение,
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	ХранилищеСохранить(
		ХранилищеНастроекДанныхФорм, 
		КлючОбъекта, 
		КлючНастроек, 
		Значение,
		ОписаниеНастроек, 
		ИмяПользователя, 
		НужноОбновитьПовторноИспользуемыеЗначения
	);
	
КонецПроцедуры

// Загружает настройку из хранилища настроек данных форм.
//
// Параметры:
//   Соответствуют методу ХранилищеСистемныхНастроек.Загрузить,
//   подробнее - см. параметры функции ХранилищеЗагрузить()
//
Функция ХранилищеНастроекДанныхФормЗагрузить(КлючОбъекта, КлючНастроек = "", ЗначениеПоУмолчанию = Неопределено, 
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	
	Возврат ХранилищеЗагрузить(
		ХранилищеНастроекДанныхФорм, 
		КлючОбъекта, 
		КлючНастроек, 
		ЗначениеПоУмолчанию, 
		ОписаниеНастроек, 
		ИмяПользователя
	);
	
КонецФункции

// Удаляет настройку из хранилища настроек данных форм.
//
// Параметры:
//   Соответствуют методу ХранилищеНастроекДанныхФорм.Удалить,
//   подробнее - см. параметры функции ХранилищеУдалить()
//
Процедура ХранилищеНастроекДанныхФормУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	
	ХранилищеУдалить(
		ХранилищеНастроекДанныхФорм,
		КлючОбъекта,
		КлючНастроек,
		ИмяПользователя
	);
	
КонецПроцедуры

// Сохраняет настройку в хранилище настроек через его менеджер.
// 
// Параметры:
//   МенеджерХранилища (СтандартноеХранилищеНастроекМенеджер) Хранилище, в котором сохраняется настройка
//   КлючОбъекта       (Строка) Ключ объекта настройки. 
//                              Подробнее см. раздел справки "Настройки, автоматически сохраняемые в системном хранилище".
//   КлючНастроек      (Строка) Ключ сохраняемых настроек.
//   Значение          (*)      Содержит настройки, которые нужно сохранить в хранилище. 
//   ОписаниеНастроек  (ОписаниеНастроек) Содержит информацию об описании настройки.
//   ИмяПользователя   (Строка) Имя пользователя, настройки которого сохраняются.
//                              Если не указано, то сохраняются настройки текущего пользователя.
//   НужноОбновитьПовторноИспользуемыеЗначения (Булево)
// 
Процедура ХранилищеСохранить(МенеджерХранилища, КлючОбъекта, КлючНастроек, Значение,
	ОписаниеНастроек, ИмяПользователя, НужноОбновитьПовторноИспользуемыеЗначения)
	
	Если НЕ ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Возврат;
	КонецЕсли;
	
	МенеджерХранилища.Сохранить(КлючОбъекта, КлючНастроек, Значение, ОписаниеНастроек, ИмяПользователя);
	
	Если НужноОбновитьПовторноИспользуемыеЗначения Тогда
		ОбновитьПовторноИспользуемыеЗначения();
	КонецЕсли;
	
КонецПроцедуры

// Загружает настройку из хранилища настроек через его менеджер.
//
// Параметры:
//   МенеджерХранилища   (СтандартноеХранилищеНастроекМенеджер) Хранилище, из которого загружается настройка
//   КлючОбъекта         (Строка) Ключ объекта настройки. 
//                                Подробнее см. раздел справки "Настройки, автоматически сохраняемые в системном хранилище".
//   КлючНастроек        (Строка) Ключ сохраняемых настроек.
//   ЗначениеПоУмолчанию (*)      Значение, которое необходимо подставить если настройки не были загружены.
//   ОписаниеНастроек    (ОписаниеНастроек) Через данный параметр при загрузке можно получить описание настроек.
//   ИмяПользователя     (Строка) Имя пользователя, настройки которого загружается.
//                                Если не указано, то загружается настройки текущего пользователя.
// 
// Возвращаемое значение: 
//   (*) Настройки, загруженные из хранилища. Неопределено, если настройки не найдены. 
// 
Функция ХранилищеЗагрузить(МенеджерХранилища, КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию,
	ОписаниеНастроек, ИмяПользователя)
	
	Результат = Неопределено;
	
	Если ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Результат = МенеджерХранилища.Загрузить(КлючОбъекта, КлючНастроек, ОписаниеНастроек, ИмяПользователя);
	КонецЕсли;
	
	Если (Результат = Неопределено) И (ЗначениеПоУмолчанию <> Неопределено) Тогда
		Результат = ЗначениеПоУмолчанию;
	КонецЕсли;

	Возврат Результат;
	
КонецФункции

// Удаляет настройку из хранилища настроек через его менеджер.
//
// Параметры:
//   МенеджерХранилища (СтандартноеХранилищеНастроекМенеджер) Хранилище, из которого удаляется настройка
//   КлючОбъекта       (Строка)       Ключ объекта настройки. 
//                     (Неопределено) Удаляются настройки для всех объектов.
//   КлючНастроек      (Строка)       Ключ сохраняемых настроек.
//                     (Неопределено) Удаляются настройки со всеми ключами.
//   ИмяПользователя   (Строка)       Имя пользователя, настройки которого загружается.
//                     (Неопределено) Удаляются настройки всех пользователей.
// 
// Возвращаемое значение: 
//   (*) Настройки, загруженные из хранилища. Неопределено, если настройки не найдены. 
// 
Процедура ХранилищеУдалить(МенеджерХранилища, КлючОбъекта, КлючНастроек, ИмяПользователя)
	
	Если ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		МенеджерХранилища.Удалить(КлючОбъекта, КлючНастроек, ИмяПользователя);
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с табличными документами

// Проверяет, умещаются ли переданные табличные документы на страницу при печати.
//
// Параметры
//  ТабДокумент        – Табличный документ
//  ВыводимыеОбласти   – Массив из проверяемых таблиц или табличный документ
//  РезультатПриОшибке - Какой возвращать результат при возникновении ошибки
//
// Возвращаемое значение:
//   Булево   – умещаются или нет переданные документы
//
Функция ПроверитьВыводТабличногоДокумента(ТабДокумент, ВыводимыеОбласти, РезультатПриОшибке = Истина) Экспорт

	Попытка
		Возврат ТабДокумент.ПроверитьВывод(ВыводимыеОбласти);
	Исключение
		Возврат РезультатПриОшибке;
	КонецПопытки;

КонецФункции 

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с журналом регистрации

// Процедура пакетной записи сообщений в журнал регистрации
// 
// Параметры: СобытияДляЖурналаРегистрации - массив структур, клиентская глобальная переменная 
// Каждая структура - сообщение для журнала регистрации.
// После записи переменная очищается.
Процедура ЗаписатьСобытияВЖурналРегистрации(СобытияДляЖурналаРегистрации) Экспорт
	
	Если ТипЗнч(СобытияДляЖурналаРегистрации) <> Тип("СписокЗначений") Тогда
		Возврат;
	КонецЕсли;	
	
	Если СобытияДляЖурналаРегистрации.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого СообщениеЖурнала Из СобытияДляЖурналаРегистрации Цикл
		ЗначениеСообщения = СообщениеЖурнала.Значение;
		ИмяСобытия = ЗначениеСообщения.ИмяСобытия;
		УровеньСобытия = УровеньСобытияПоПредставлению(ЗначениеСообщения.ПредставлениеУровня);
		ДатаСобытия = ТекущаяДатаСеанса();
		Если ЗначениеСообщения.Свойство("ДатаСобытия") И ЗначениеЗаполнено(ЗначениеСообщения.ДатаСобытия) Тогда
			ДатаСобытия = ЗначениеСообщения.ДатаСобытия;
		КонецЕсли;
		Комментарий = Строка(ДатаСобытия) + " " + ЗначениеСообщения.Комментарий;
		ЗаписьЖурналаРегистрации(ИмяСобытия, УровеньСобытия,,, Комментарий);
	КонецЦикла;
	СобытияДляЖурналаРегистрации.Очистить();
	
КонецПроцедуры

// Включить запись уровней событий СписокУровней в журнале регистрации.
//
// Параметры: УровниСобытий - СписокЗначений - наименования уровней регистрации событий, 
//                                             которые необходимо включить
//
Процедура ВключитьИспользованиеЖурналаРегистрации(СписокУровней = Неопределено) Экспорт
	
	МассивУровней = Новый Массив();
	Если СписокУровней = Неопределено Тогда
		МассивУровней.Добавить(УровеньЖурналаРегистрации.Информация);
		МассивУровней.Добавить(УровеньЖурналаРегистрации.Ошибка);
		МассивУровней.Добавить(УровеньЖурналаРегистрации.Предупреждение);
		МассивУровней.Добавить(УровеньЖурналаРегистрации.Примечание);
	Иначе
		МассивУровней = УровниСобытияЖурналаРегистрацииПоСтроке(СписокУровней);
	КонецЕсли;
	
	МонопольныйРежимУстановленРанее = МонопольныйРежим();
	УстановитьМонопольныйРежим(Истина);
	
	Попытка
		УстановитьИспользованиеЖурналаРегистрации(МассивУровней);
	Исключение
		Если Не МонопольныйРежимУстановленРанее Тогда
			УстановитьМонопольныйРежим(Ложь);
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Проверяет, включена ли регистрация событий УровниСобытий в журнале регистрации.
//
// Параметры: 
//   УровниСобытий - СписокЗначений - список строк с уровнями регистрации событий журнала регистрации, 
//                                    для которых необходимо проверить, что они включены.
//                                    Если Неопределено, то проверяются все уровни событий.
//
// Возвращаемое значение: 
//   Булево - Истина, когда заданные режимы включены. Иначе - Ложь.
//
Функция ПроверитьВключениеЖурналаРегистрации(УровниСобытий = Неопределено) Экспорт	
	
	УстановленныеУровниСобытий = ПолучитьИспользованиеЖурналаРегистрации();
	Если УровниСобытий = Неопределено Тогда
		Возврат УстановленныеУровниСобытий.Количество() = 4; // включены все уровни событий?
	КонецЕсли;
	
	ИменаУровнейСобытий = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(УровниСобытий);
	Для Каждого Название Из ИменаУровнейСобытий Цикл
		УровеньСобытия = УровеньСобытияПоПредставлению(Название);
		Если УстановленныеУровниСобытий.Найти(УровеньСобытия) = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции для работы в режиме разделения данных

// Устанавливает монопольный доступ к информационной базе (области данных).
//
// При включенном использовании разделителей в сеансе
// начинает транзакцию и устанавливает исключительную управляемую блокировку
// на пространства блокировок всех объектов метаданных, входящих в состав разделителя ОбластьДанных.
//
// В других случаях (например, в локальном режиме работы) устанавливает монопольный режим. 
//
// Параметры:
// ПроверитьОтсутствиеДругихСеансов - Булево - проверить отсутствие других
// пользовательских сеансов со значением разделителя равным текущему.
// В случае обнаружения других сеансов будет выдано исключение.
// Параметр используется только при работе в модели сервиса.
//
Процедура ЗаблокироватьИБ(Знач ПроверитьОтсутствиеДругихСеансов = Истина) Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() 
		ИЛИ НЕ ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		
		Если НЕ МонопольныйРежим() Тогда
			УстановитьМонопольныйРежим(Истина);
		КонецЕсли;
	Иначе
		СтандартныеПодсистемыПереопределяемый.ЗаблокироватьТекущуюОбластьДанных(ПроверитьОтсутствиеДругихСеансов);
	КонецЕсли;
		
КонецПроцедуры

// Снимает монопольный доступ к информационной базе (области данных).
//
// При включенном использовании разделителей в сеансе,
// - если вызов делается внутри обработчика исключения (из секции Исключении...)
//   отменяет транзакцию;
// - иначе фиксирует транзакцию.
//
// В других случаях (например, в локальном режиме работы) снимает монопольный режим. 
//
Процедура РазблокироватьИБ() Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() 
		ИЛИ НЕ ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		
		Если МонопольныйРежим() Тогда
			УстановитьМонопольныйРежим(Ложь);
		КонецЕсли;
	Иначе
		СтандартныеПодсистемыПереопределяемый.РазблокироватьТекущуюОбластьДанных();
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает разделение сеанса.
//
// Параметры:
// Использование - Булево - Использование разделителя ОбластьДанных в сеансе
// ОбластьДанных - Число - Значение разделителя ОбластьДанных
//
Процедура УстановитьРазделениеСеанса(Знач Использование, Знач ОбластьДанных = Неопределено) Экспорт
	
	СтандартныеПодсистемыПереопределяемый.УстановитьРазделениеСеанса(Использование, ОбластьДанных);
	
КонецПроцедуры

// Возвращает значение разделителя текущей области данных.
// В случае если значение не установлено выдается ошибка.
// 
// Возвращаемое значение: 
// Тип значения разделителя.
// Значение разделителя текущей области данных. 
// 
Функция ЗначениеРазделителяСеанса() Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		Возврат 0;
	Иначе
		Возврат СтандартныеПодсистемыПереопределяемый.ЗначениеРазделителяСеанса();
	КонецЕсли;
	
КонецФункции

// Возвращает флаг использования разделителя ОбластьДанных для текущего сеанса.
// 
// Возвращаемое значение: 
// Булево - Истина разделение используется, иначе нет.
// 
Функция ИспользованиеРазделителяСеанса() Экспорт
	
	Возврат СтандартныеПодсистемыПереопределяемый.ИспользованиеРазделителяСеанса();
	
КонецФункции

// Процедура инициализации разделенной информационной базы
// 
// Параметры:
// ВключитьРазделение - Булево - признак включения разделения в
// информационной базе
//
Процедура УстановитьПараметрыРазделенияИнформационныйБазы(Знач ВключитьРазделение = Ложь) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	Если ВключитьРазделение Тогда
		Константы.ИспользоватьРазделениеПоОбластямДанных.Установить(Истина);
	Иначе
		Константы.НеИспользоватьРазделениеПоОбластямДанных.Установить(Истина);
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает значение двух дополнительных констант.
// Имена констант строго регламентированы и должны соответствовать шаблонам:
//  <Имя основной константы>ВМоделиСервиса
//  <Имя основной константы>ВЛокальномРежиме
//
// Параметры:
//  Значение – Булево – значение основной константы.
//  ИмяКонстанты – Строка – имя основной константы.
//
Процедура УстановитьЗначенияДополнительныхКонстант(Знач Значение, Знач ИмяКонстанты) Экспорт
	
	Если Значение = Истина Тогда
		
		РазделениеВключено = ОбщегоНазначенияПовтИсп.РазделениеВключено();
		
		Константы[ИмяКонстанты + "ВМоделиСервиса"].Установить(РазделениеВключено);
		Константы[ИмяКонстанты + "ВЛокальномРежиме"].Установить(Не РазделениеВключено);
		
	Иначе
		
		Константы[ИмяКонстанты + "ВМоделиСервиса"].Установить(Ложь);
		Константы[ИмяКонстанты + "ВЛокальномРежиме"].Установить(Ложь);
		
	КонецЕсли;
	
КонецПроцедуры

/////////////////////////////////////////////////////////////////////////////////
// Версионирование программных интерфейсов

// Возвращает массив номеров версий, поддерживаемых интерфейсом удаленной системы.
//
// Параметры:
//  ПараметрыПодключения - Структура:
//							- URL - Строка - URL сервиса. Обязательно должно присутствовать и быть заполненным.
//							- UserName - Строка - Имя пользователя сервиса.
//							- Password - Строка - Пароль пользователя сервиса.
//  ИмяИнтерфейса - Строка.
//
// Параметры:
//  Адрес - Строка - адрес web-сервиса версионирования интерфейсовв
//  Пользователь - Строка - имя пользователя
//  Пароль - Строка - пароль пользователя
//  Интерфейс - Строка - имя интерфейса
//
//
// Возвращаемое значение:
// ФиксированныйМассив - Массив строк:
//	- Каждая строка является представлением номера версии интерфейса. Например, "1.0.2.1".
//
// Пример использования:
//	  ПараметрыПодключения = Новый Структура;
//	  ПараметрыПодключения.Вставить("URL", "http://vsrvx/sm");
//	  ПараметрыПодключения.Вставить("UserName", "ivanov");
//	  МассивВерсий = ПолучитьВерсииИнтерфейса(ПараметрыПодключения, "СервисПередачиФайлов");
//
// Примечание: при получении версий используется кэш, время обновления которого составляет
//  одни сутки. Если для целей отладки требуется обновить значения в кэше, раньше этого 
//  времени, следует удалить из регистра сведений КэшПрограммныхИнтерфейсов соответствующие 
//  записи.
//
Функция ПолучитьВерсииИнтерфейса(Знач Адрес, Знач Пользователь, Знач Пароль = Неопределено, Знач Интерфейс = Неопределено) Экспорт
	
	Если ТипЗнч(Адрес) = Тип("Структура") Тогда
		ПараметрыПодключения = Адрес;
		ИмяИнтерфейса = Пользователь;
	Иначе
		ПараметрыПодключения = Новый Структура;
		ПараметрыПодключения.Вставить("URL", Адрес);
		ПараметрыПодключения.Вставить("UserName", Пользователь);
		ПараметрыПодключения.Вставить("Password", Пароль);
		ИмяИнтерфейса = Интерфейс;
	КонецЕсли;
	
	Если Не ПараметрыПодключения.Свойство("URL") 
		Или Не ЗначениеЗаполнено(ПараметрыПодключения.URL) Тогда
		
		ВызватьИсключение(НСтр("ru = 'Не задан URL сервиса.'"));
	КонецЕсли;
	
	ПараметрыПолучения = Новый Массив;
	ПараметрыПолучения.Добавить(ПараметрыПодключения);
	ПараметрыПолучения.Добавить(ИмяИнтерфейса);
	
	Возврат ОбщегоНазначенияПовтИсп.ПолучитьДанныеКэшаВерсий(
		ИдентификаторЗаписиКэшаВерсий(ПараметрыПодключения.URL, ИмяИнтерфейса), 
		Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ВерсииИнтерфейса, 
		ЗначениеВСтрокуXML(ПараметрыПолучения),
		Истина);
	
КонецФункции

// Возвращает массив номеров версий, поддерживаемых интерфейсом системы, подключенной через внешнее соединение.
//
// Параметры:
// ВнешнееСоединение - объект COM-соединение, которое используется для работы с корреспондентом.
// ИмяИнтерфейса - Строка.
//
// Возвращаемое значение:
// ФиксированныйМассив - Массив строк:
//  Каждая строка является представлением номера версии интерфейса. Например, "1.0.2.1".
//
// Пример использования:
//  Параметры = ...
//  ВнешнееСоединение = ОбщегоНазначения.УстановитьВнешнееСоединение(Параметры);
//  МассивВерсий = ОбщегоНазначения.ПолучитьВерсииИнтерфейсаЧерезВнешнееСоединение(ВнешнееСоединение, "ОбменДанными");
//
Функция ПолучитьВерсииИнтерфейсаЧерезВнешнееСоединение(ВнешнееСоединение, Знач ИмяИнтерфейса) Экспорт
	
	Попытка
		ВерсииИнтерфейсаXML = ВнешнееСоединение.СтандартныеПодсистемыСервер.ПоддерживаемыеВерсии(ИмяИнтерфейса);
	Исключение
		СтрокаСообщения = НСтр("ru = 'Корреспондент не поддерживает версионирование интерфейсов подсистем.
			|Описание ошибки: %1'"
		);
		СтрокаСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщения, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Получение версий интерфейса'"), УровеньЖурналаРегистрации.Ошибка,,, СтрокаСообщения);
		
		Возврат Новый ФиксированныйМассив(Новый Массив);
	КонецПопытки;
	
	Возврат Новый ФиксированныйМассив(ЗначениеИзСтрокиXML(ВерсииИнтерфейсаXML));
КонецФункции

// Удаляет записи кэша версий содержащих в идентификаторе указанную
// подстроку. В качестве подстроки может использоваться, например,
// имя интерфейса более не используемого в конфигурации.
//
// Параметры:
//  ПодстрокаПоискаИдентификаторов - Строка - подстрока поиска 
//   идентификаторов. Строка не может содержать символов
//   %, _ и [
//
Процедура УдалитьЗаписиКэшаВерсий(Знач ПодстрокаПоискаИдентификаторов) Экспорт
	
	НачатьТранзакцию();
	
	Попытка
		Блокировка = Новый БлокировкаДанных;
		Блокировка.Добавить("РегистрСведений.КэшПрограммныхИнтерфейсов");
		Блокировка.Заблокировать();
		
		Запрос = Новый Запрос;
		Запрос.Текст =
		"ВЫБРАТЬ
		|	КэшПрограммныхИнтерфейсов.Идентификатор КАК Идентификатор,
		|	КэшПрограммныхИнтерфейсов.ТипДанных КАК ТипДанных
		|ИЗ
		|	РегистрСведений.КэшПрограммныхИнтерфейсов КАК КэшПрограммныхИнтерфейсов
		|ГДЕ
		|	КэшПрограммныхИнтерфейсов.Идентификатор ПОДОБНО ""%" + СформироватьСтрокуДляПоискаВЗапросе(ПодстрокаПоискаИдентификаторов) + "%""
		|		СПЕЦСИМВОЛ ""~""";
		Результат = Запрос.Выполнить();
		Выборка = Результат.Выбрать();
		Пока Выборка.Следующий() Цикл
			Запись = РегистрыСведений.КэшПрограммныхИнтерфейсов.СоздатьМенеджерЗаписи();
			Запись.Идентификатор = Выборка.Идентификатор;
			Запись.ТипДанных = Выборка.ТипДанных;
			Запись.Удалить();
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// СЛУЖЕБНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

Функция УровеньСобытияПоПредставлению(ПредставлениеУровня)
	Если ПредставлениеУровня = "Информация" Тогда
		Возврат УровеньЖурналаРегистрации.Информация;
	ИначеЕсли ПредставлениеУровня = "Ошибка" Тогда
		Возврат УровеньЖурналаРегистрации.Ошибка;
	ИначеЕсли ПредставлениеУровня = "Предупреждение" Тогда
		Возврат УровеньЖурналаРегистрации.Предупреждение; 
	ИначеЕсли ПредставлениеУровня = "Примечание" Тогда
		Возврат УровеньЖурналаРегистрации.Примечание;
	КонецЕсли;	
КонецФункции

Функция УровниСобытияЖурналаРегистрацииПоСтроке(СписокУровней)
	МассивНазванийУровней = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СписокУровней);
	МассивУровней = Новый Массив;
	Для Каждого Название Из МассивНазванийУровней Цикл
		МассивУровней.Добавить(УровеньСобытияПоПредставлению(Название));
	КонецЦикла;
	Возврат МассивУровней;
КонецФункции

Процедура НоваяСтрокаКоллекцииОбъектовМетаданных(Имя, Синоним, Картинка, КартинкаОбъекта, Таб)
	
	НоваяСтрока = Таб.Добавить();
	НоваяСтрока.Имя               = Имя;
	НоваяСтрока.Синоним           = Синоним;
	НоваяСтрока.Картинка          = Картинка;
	НоваяСтрока.КартинкаОбъекта   = КартинкаОбъекта;
	
КонецПроцедуры

Процедура ОбновитьДанныеКэшаВерсий(Знач Идентификатор, Знач ТипДанных, Знач ПараметрыПолучения) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	КэшПрограммныхИнтерфейсов.ДатаОбновления КАК ДатаОбновления,
	|	КэшПрограммныхИнтерфейсов.Данные КАК Данные,
	|	КэшПрограммныхИнтерфейсов.ТипДанных КАК ТипДанных
	|ИЗ
	|	РегистрСведений.КэшПрограммныхИнтерфейсов КАК КэшПрограммныхИнтерфейсов
	|ГДЕ
	|	КэшПрограммныхИнтерфейсов.Идентификатор = &Идентификатор
	|	И КэшПрограммныхИнтерфейсов.ТипДанных = &ТипДанных";
	Идентификатор = Идентификатор;
	Запрос.УстановитьПараметр("Идентификатор", Идентификатор);
	Запрос.УстановитьПараметр("ТипДанных", ТипДанных);
	
	НачатьТранзакцию();
	
	Попытка
	
		Блокировка = Новый БлокировкаДанных;
		ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.КэшПрограммныхИнтерфейсов");
		ЭлементБлокировки.УстановитьЗначение("Идентификатор", Идентификатор);
		ЭлементБлокировки.УстановитьЗначение("ТипДанных", ТипДанных);
		Блокировка.Заблокировать();
		
		Результат = Запрос.Выполнить();
		
		// Убедимся что данные требуют обновления
		Если НЕ Результат.Пустой() Тогда
			Выборка = Результат.Выбрать();
			Выборка.Следующий();
			Если НЕ ЗаписьКэшаВерсийУстарела(Выборка) Тогда
				// Данные актуальны
				ОтменитьТранзакцию();
				Возврат;
			КонецЕсли;
		КонецЕсли;
		
		Если ТипДанных = Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ВерсииИнтерфейса Тогда
			Данные = ПолучитьВерсииИнтерфейсаВКэш(ПараметрыПолучения[0], ПараметрыПолучения[1]);
		ИначеЕсли ТипДанных = Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ОписаниеWebСервиса Тогда
			Данные = ПолучитьWSDL(ПараметрыПолучения[0], ПараметрыПолучения[1], ПараметрыПолучения[2]);
		Иначе
			ШаблонТекста = НСтр("ru = 'Не известный тип данных кэша версий: %1'");
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонТекста, ТипДанных);
			ВызватьИсключение(ТекстСообщения);
		КонецЕсли;
		
		МенеджерЗаписи = РегистрыСведений.КэшПрограммныхИнтерфейсов.СоздатьМенеджерЗаписи();
		МенеджерЗаписи.Идентификатор = Идентификатор;
		МенеджерЗаписи.ТипДанных = ТипДанных;
		МенеджерЗаписи.ДатаОбновления = ТекущаяУниверсальнаяДата();
		МенеджерЗаписи.Данные = Новый ХранилищеЗначения(Данные);
		МенеджерЗаписи.Записать();
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

Функция ЗаписьКэшаВерсийУстарела(Знач Запись) Экспорт
	
	Если Запись.ТипДанных = Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ОписаниеWebСервиса Тогда
		Возврат НЕ ЗначениеЗаполнено(Запись.ДатаОбновления)
	Иначе
		Возврат Запись.ДатаОбновления + 86400 < ТекущаяУниверсальнаяДата();
	КонецЕсли;
	
КонецФункции

Функция ИдентификаторЗаписиКэшаВерсий(Знач Адрес, Знач Имя) Экспорт
	
	Возврат Адрес + "|" + Имя;
	
КонецФункции

Функция ПолучитьВерсииИнтерфейсаВКэш(Знач ПараметрыПодключения, Знач ИмяИнтерфейса)
	
	Если Не ПараметрыПодключения.Свойство("URL") 
		Или Не ЗначениеЗаполнено(ПараметрыПодключения.URL) Тогда
		
		ВызватьИсключение(НСтр("ru = 'Не задан URL сервиса.'"));
	КонецЕсли;
	
	Если ПараметрыПодключения.Свойство("UserName")
		И ЗначениеЗаполнено(ПараметрыПодключения.UserName) Тогда
		
		ИмяПользователя = ПараметрыПодключения.UserName;
		
		Если ПараметрыПодключения.Свойство("Password") Тогда
			ПарольПользователя = ПараметрыПодключения.Password;
		Иначе
			ПарольПользователя = Неопределено;
		КонецЕсли;
		
	Иначе
		ИмяПользователя = Неопределено;
		ПарольПользователя = Неопределено;
	КонецЕсли;
	
	АдресСервиса = ПараметрыПодключения.URL + "/ws/InterfaceVersion?wsdl";
	
	ПроксиВерсионирования = WSПрокси(АдресСервиса, "http://www.1c.ru/SaaS/1.0/WS",
		"InterfaceVersion", , ИмяПользователя, ПарольПользователя, 3);
		
	МассивXDTO = ПроксиВерсионирования.GetVersions(ИмяИнтерфейса);
	Если МассивXDTO = Неопределено Тогда
		Возврат Новый ФиксированныйМассив(Новый Массив);
	Иначе	
		Сериализатор = Новый СериализаторXDTO(ПроксиВерсионирования.ФабрикаXDTO);
		Возврат Новый ФиксированныйМассив(Сериализатор.ПрочитатьXDTO(МассивXDTO));
	КонецЕсли;
	
КонецФункции

Функция ПолучитьWSDL(Знач Адрес, Знач ИмяПользователя, Знач Пароль)
	
	ПараметрыПолучения = Новый Структура;
	Если НЕ ПустаяСтрока(ИмяПользователя) Тогда
		ПараметрыПолучения.Вставить("Пользователь", ИмяПользователя);
		ПараметрыПолучения.Вставить("Пароль", Пароль);
	КонецЕсли;
	ПараметрыПолучения.Вставить("Таймаут", 3);
	
	ОписаниеФайла = Неопределено;
	СтандартныеПодсистемыПереопределяемый.СкачатьФайлНаСервере(Адрес, ПараметрыПолучения, ОписаниеФайла);
	
	Если НЕ ОписаниеФайла.Статус Тогда
		ВызватьИсключение(НСтр("ru = 'Ошибка получения файла описания web-сервиса:'") + Символы.ПС + ОписаниеФайла.СообщениеОбОшибке)
	КонецЕсли;
	
	// Попробуем создать WS определения на основе полученного файла
	Определения = Новый WSОпределения(ОписаниеФайла.Путь);
	Если Определения.Сервисы.Количество() = 0 Тогда
		ШаблонСообщения = НСтр("ru = 'Ошибка получения файла описания web-сервиса:
			|В полученном файле не содержится ни одного описания сервиса.
			|
			|Возможно, адрес файла описания указан неверно:
			|%1'");
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, Адрес);
		ВызватьИсключение(ТекстСообщения);
	КонецЕсли;
	Определения = Неопределено;
	
	ДанныеФайла = Новый ДвоичныеДанные(ОписаниеФайла.Путь);
	
	УдалитьФайлыПоИмени(ОписаниеФайла.Путь);
		
	Возврат ДанныеФайла;
	
КонецФункции

Процедура УдалитьФайлыПоИмени(ИмяФайла)
	#Если Не Сервер Тогда
		НачатьУдалениеФайлов(Новый ОписаниеОповещения("УдалитьФайлыПоИмениЗавершение", ЭтотОбъект,,"УдалитьФайлыПоИмениОшибка",ЭтотОбъект), ИмяФайла);Иначе
	#Иначе	
		Попытка
			УдалитьФайлы(ИмяФайла);
		Исключение
			ЗаписьЖурналаРегистрации(НСтр("ru = 'Получение WSDL'"), УровеньЖурналаРегистрации.Ошибка, , , 
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;
	#КонецЕсли
КонецПроцедуры

Процедура УдалитьФайлыПоИмениЗавершение(ДополнительныеПараметры) Экспорт
	
КонецПроцедуры

Процедура УдалитьФайлыПоИмениОшибка(ИнформацияОбОшибке, СтандартнаяОбработка, ДополнительныеПараметры) Экспорт
	 СтандартнаяОбработка = Ложь;
	 
	 ЗаписьЖурналаРегистрации(НСтр("ru = 'Получение WSDL'"), УровеньЖурналаРегистрации.Ошибка, , , 
		ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));

КонецПроцедуры

Функция ПлатформаПоддерживаетТаймаутыСети() Экспорт
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	Возврат ОбщегоНазначенияКлиентСервер.СравнитьВерсии(СистемнаяИнформация.ВерсияПриложения, "8.2.16.0") >= 0;
	
КонецФункции

// Функция возвращает объект WSОпределения созданный с переданными параметрами.
//
// Параметры:
//  АдресWSDL - Строка - местораположение wsdl
//  ИмяПользователя - Строка - имя пользователя для входа на сервер
//  Пароль - Строка - пароль пользователя
//
// Примечание: при получении определения используется кэш, обновление которого осуществляется
//  при смене версии конфигурации. Если для целей отладки требуется обновить
//  значения в кэше, раньше этого времени, следует удалить из регистра сведений 
//  КэшПрограммныхИнтерфейсов соответствующие записи.
//
Функция WSОпределения(Знач АдресWSDL, Знач ИмяПользователя, Знач Пароль) Экспорт
	
	ДоступноПолучениеФайловИзИнтернета = Неопределено;
	СтандартныеПодсистемыПереопределяемый.ДоступноПолучениеФайловИзИнтернета(ДоступноПолучениеФайловИзИнтернета);
	Если ДоступноПолучениеФайловИзИнтернета = Истина Тогда
	
		ПараметрыПолучения = Новый Массив;
		ПараметрыПолучения.Добавить(АдресWSDL);
		ПараметрыПолучения.Добавить(ИмяПользователя);
		ПараметрыПолучения.Добавить(Пароль);
		
		ДанныеWSDL = ОбщегоНазначенияПовтИсп.ПолучитьДанныеКэшаВерсий(
			АдресWSDL, 
			Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ОписаниеWebСервиса, 
			ЗначениеВСтрокуXML(ПараметрыПолучения),
			Ложь);
			
		ИмяФайлаWSDL = ПолучитьИмяВременногоФайла("wsdl");
		
		ДанныеWSDL.Записать(ИмяФайлаWSDL);
		
		Определения = Новый WSОпределения(ИмяФайлаWSDL);
		
		УдалитьФайлыПоИмени(ИмяФайлаWSDL);
		
		Возврат Определения;
		
	Иначе
		
		Параметры = Новый Массив;
		Параметры.Добавить(АдресWSDL);
		Параметры.Добавить(ИмяПользователя);
		Параметры.Добавить(Пароль);
	
		Если ПлатформаПоддерживаетТаймаутыСети() Тогда
			Параметры.Добавить(3);
		КонецЕсли;
		
		Возврат Новый(Тип("WSОпределения"), Параметры);
		
	КонецЕсли;
	
КонецФункции

// Функция возвращает объект WSПрокси созданный с переданными параметрами.
//
// Параметры:
//  АдресWSDL - Строка - местораположение wsdl
//  URIПространстваИмен - Строка - URI пространства имен web-сервиса
//  ИмяСервиса - Строка - имя сервиса
//  ИмяТочкиПодключения - Строка - если не задано, образуется как <ИмяСервиса>Soap
//  ИмяПользователя - Строка - имя пользователя для входа на сервер
//  Пароль - Строка - пароль пользователя
//  Таймаут - Число - таймаут на операции выполняемые через полученное прокси 
//
// Возвращаемое значение:
//  WSПрокси
//
Функция ВнутренняяWSПрокси(Знач АдресWSDL, Знач URIПространстваИмен, Знач ИмяСервиса,
	Знач ИмяТочкиПодключения = "", Знач ИмяПользователя, Знач Пароль,
	Знач Таймаут = Неопределено) Экспорт
	
	WSОпределения = ОбщегоНазначенияПовтИсп.WSОпределения(АдресWSDL, ИмяПользователя, Пароль);
	
	Если ПустаяСтрока(ИмяТочкиПодключения) Тогда
		ИмяТочкиПодключения = ИмяСервиса + "Soap";
	КонецЕсли;
	
	Параметры = Новый Массив;
	Параметры.Добавить(WSОпределения);
	Параметры.Добавить(URIПространстваИмен);
	Параметры.Добавить(ИмяСервиса);
	Параметры.Добавить(ИмяТочкиПодключения);
	Если ПлатформаПоддерживаетТаймаутыСети() Тогда
		Параметры.Добавить(Таймаут);
	КонецЕсли;
	
	Прокси = Новый(Тип("WSПрокси"), Параметры);
	Прокси.Пользователь = ИмяПользователя;
	Прокси.Пароль = Пароль;
	
	Возврат Прокси;
КонецФункции

Функция ИмяКоллекции(ПолноеИмя)
	
	ПозицияТочки = СтрНайти(ПолноеИмя, ".");
	
	Если ПозицияТочки > 0 Тогда
		Возврат Лев(ПолноеИмя, ПозицияТочки - 1);
	КонецЕсли;
	
	Возврат "";
	
КонецФункции


